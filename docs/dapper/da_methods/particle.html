<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>dapper.da_methods.particle API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dapper.da_methods.particle</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dapper.da_methods.particle.trigger_resampling"><code class="name flex">
<span>def <span class="ident">trigger_resampling</span></span>(<span>w, NER, stat_args)</span>
</code></dt>
<dd>
<div class="desc"><p>Return boolean: N_effective &lt;= threshold. Also write stats.</p></div>
</dd>
<dt id="dapper.da_methods.particle.reweight"><code class="name flex">
<span>def <span class="ident">reweight</span></span>(<span>w, lklhd=None, logL=None, innovs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Do Bayes' rule (for the empirical distribution of an importance sample).</p>
<p>Do computations in log-space, for at least 2 reasons:
- Normalization: will fail if sum==0 (if all innov's are large).
- Num. precision: lklhd*w should have better precision in log space.
Output is non-log, for the purpose of assessment and resampling.</p>
<p>If input is 'innovs': likelihood := NormDist(innovs|0,Id).</p></div>
</dd>
<dt id="dapper.da_methods.particle.raw_C12"><code class="name flex">
<span>def <span class="ident">raw_C12</span></span>(<span>E, w)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the 'raw' matrix-square-root of the ensemble' covariance.</p>
<p>The weights are used both for the mean and anomalies (raw sqrt).</p>
<p>Note: anomalies (and thus cov) are weighted,
and also computed based on a weighted mean.</p></div>
</dd>
<dt id="dapper.da_methods.particle.mask_unique_of_sorted"><code class="name flex">
<span>def <span class="ident">mask_unique_of_sorted</span></span>(<span>idx)</span>
</code></dt>
<dd>
<div class="desc"><p>NB: returns a mask which is True at [i] iff idx[i] is NOT unique.</p></div>
</dd>
<dt id="dapper.da_methods.particle.auto_bandw"><code class="name flex">
<span>def <span class="ident">auto_bandw</span></span>(<span>N, M)</span>
</code></dt>
<dd>
<div class="desc"><p>"Optimal bandwidth (not bandwidth^2), as per Scott's rule-of-thumb.</p>
<p>Refs: [Dou01]<em> section 12.2.2, and [Wik17]</em> section "Rule_of_thumb"</p></div>
</dd>
<dt id="dapper.da_methods.particle.regularize"><code class="name flex">
<span>def <span class="ident">regularize</span></span>(<span>C12, E, idx, no_uniq_jitter)</span>
</code></dt>
<dd>
<div class="desc"><p>Jitter (add noise).</p>
<p>After resampling some of the particles will be identical.
Therefore, if noise.is_deterministic: some noise must be added.
This is adjusted by the regularization 'reg' factor
(so-named because Dirac-deltas are approximated
Gaussian kernels),
which controls the strength of the jitter.
This causes a bias. But, as N&ndash;&gt;∞, the reg. bandwidth&ndash;&gt;0, i.e. bias&ndash;&gt;0.
Ref: [Dou01]_, section 12.2.2.</p></div>
</dd>
<dt id="dapper.da_methods.particle.resample"><code class="name flex">
<span>def <span class="ident">resample</span></span>(<span>w, kind='Systematic', N=None, wroot=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Multinomial resampling [Dou09]<em>, [van09]</em>, [Liu01]_.</p>
<ul>
<li>
<p>kind: 'Systematic', 'Residual' or 'Stochastic'.
'Stochastic' corresponds to np.random.choice() or np.random.multinomial().
'Systematic' and 'Residual' are more systematic (less stochastic)
varaitions of 'Stochastic' sampling.
Among the three, 'Systematic' is fastest, introduces the least noise,
and brings continuity benefits for localized particle filters,
and is therefore generally prefered.
Example: see dpr_data/doc_snippets/ex_resample.py.</p>
</li>
<li>
<p>N can be different from len(w)
(e.g. in case some particles have been elimintated).</p>
</li>
<li>
<p>wroot: Adjust weights before resampling by this root to
promote particle diversity and mitigate thinning.
The outcomes of the resampling are then weighted to maintain un-biased-ness.
Ref: [Liu01]_, section 3.1</p>
</li>
</ul>
<p>Note: (a) resampling methods are beneficial because they discard
low-weight ("doomed") particles and reduce the variance of the weights.
However, (b) even unbiased/rigorous resampling methods introduce noise;
(increases the var of any empirical estimator, see [1], section 3.4).
How to unify the seemingly contrary statements of (a) and (b) ?
By recognizing that we're in the <em>sequential/dynamical</em> setting,
and that <em>future</em> variance may be expected to be lower by focusing
on the high-weight particles which we anticipate will
have more informative (and less variable) future likelihoods.</p></div>
</dd>
<dt id="dapper.da_methods.particle.sample_quickly_with"><code class="name flex">
<span>def <span class="ident">sample_quickly_with</span></span>(<span>C12, N=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gaussian sampling in the quickest fashion.</p>
<p>Method depends on the size of the colouring matrix <code>C12</code>.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dapper.da_methods.particle.PartFilt"><code class="flex name class">
<span>class <span class="ident">PartFilt</span></span>
<span>(</span><span>N: int, reg: float = 0, nuj: bool = True, qroot: float = 1.0, wroot: float = 1.0, NER: float = 1.0, resampl: str = 'Sys')</span>
</code></dt>
<dd>
<div class="desc"><p>Particle filter ≡ Sequential importance (re)sampling SIS (SIR).</p>
<p>Refs: [Wik07]<em>, [van09]</em>, [Che03]_</p>
<p>This is the bootstrap version: the proposal density is just
:math:<code>q(x_{0:t} \mid y_{1:t}) = p(x_{0:t}) = p(x_t \mid x_{t-1}) p(x_{0:t-1})</code></p>
<p>Tuning settings:</p>
<ul>
<li>NER: Trigger resampling whenever N_eff &lt;= N*NER.
If resampling with some variant of 'Multinomial',
no systematic bias is introduced.</li>
<li>qroot: "Inflate" (anneal) the proposal noise kernels
by this root to increase diversity.
The weights are updated to maintain un-biased-ness.
See [Che03]_, section VI-M.2</li>
</ul></div>
<h3>Class variables</h3>
<dl>
<dt id="dapper.da_methods.particle.PartFilt.N"><code class="name">var <span class="ident">N</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PartFilt.reg"><code class="name">var <span class="ident">reg</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PartFilt.nuj"><code class="name">var <span class="ident">nuj</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PartFilt.qroot"><code class="name">var <span class="ident">qroot</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PartFilt.wroot"><code class="name">var <span class="ident">wroot</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PartFilt.NER"><code class="name">var <span class="ident">NER</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PartFilt.resampl"><code class="name">var <span class="ident">resampl</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PartFilt.da_method"><code class="name">var <span class="ident">da_method</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dapper.da_methods.particle.PartFilt.assimilate"><code class="name flex">
<span>def <span class="ident">assimilate</span></span>(<span>self, HMM, xx, yy)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="dapper.da_methods.particle.OptPF"><code class="flex name class">
<span>class <span class="ident">OptPF</span></span>
<span>(</span><span>N: int, Qs: float, reg: float = 0, nuj: bool = True, wroot: float = 1.0, NER: float = 1.0, resampl: str = 'Sys')</span>
</code></dt>
<dd>
<div class="desc"><p>'Optimal proposal' particle filter, also known as 'Implicit particle filter'.</p>
<p>Ref: [Boc10]_.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Regularization (<code>Qs</code>) is here added BEFORE Bayes' rule.</p>
<p>If <code>Qs==0</code>: OptPF should be equal to
the bootstrap filter :func:<code><a title="dapper.da_methods.particle.PartFilt" href="#dapper.da_methods.particle.PartFilt">PartFilt</a></code>.</p>
</div></div>
<h3>Class variables</h3>
<dl>
<dt id="dapper.da_methods.particle.OptPF.N"><code class="name">var <span class="ident">N</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.OptPF.Qs"><code class="name">var <span class="ident">Qs</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.OptPF.reg"><code class="name">var <span class="ident">reg</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.OptPF.nuj"><code class="name">var <span class="ident">nuj</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.OptPF.wroot"><code class="name">var <span class="ident">wroot</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.OptPF.NER"><code class="name">var <span class="ident">NER</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.OptPF.resampl"><code class="name">var <span class="ident">resampl</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.OptPF.da_method"><code class="name">var <span class="ident">da_method</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dapper.da_methods.particle.OptPF.assimilate"><code class="name flex">
<span>def <span class="ident">assimilate</span></span>(<span>self, HMM, xx, yy)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="dapper.da_methods.particle.PFa"><code class="flex name class">
<span>class <span class="ident">PFa</span></span>
<span>(</span><span>N: int, alpha: float, reg: float = 0, nuj: bool = True, qroot: float = 1.0, NER: float = 1.0, resampl: str = 'Sys')</span>
</code></dt>
<dd>
<div class="desc"><p>PF with weight adjustment withOUT</p>
<p>compensating for the bias it introduces.</p>
<p>'alpha' sets wroot before resampling such that N_effective becomes &gt;alpha*N.</p>
<p>Using alpha≈NER usually works well.</p>
<p>Explanation:
Recall that the bootstrap particle filter has "no" bias,
but significant variance (which is reflected in the weights).
The EnKF is quite the opposite.
Similarly, by adjusting the weights we play on the bias-variance spectrum.</p>
<p>NB: This does not mean that we make a PF-EnKF hybrid
&ndash; we're only playing on the weights.</p>
<p>Hybridization with xN did not show much promise.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="dapper.da_methods.particle.PFa.N"><code class="name">var <span class="ident">N</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFa.alpha"><code class="name">var <span class="ident">alpha</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFa.reg"><code class="name">var <span class="ident">reg</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFa.nuj"><code class="name">var <span class="ident">nuj</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFa.qroot"><code class="name">var <span class="ident">qroot</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFa.NER"><code class="name">var <span class="ident">NER</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFa.resampl"><code class="name">var <span class="ident">resampl</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFa.da_method"><code class="name">var <span class="ident">da_method</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dapper.da_methods.particle.PFa.assimilate"><code class="name flex">
<span>def <span class="ident">assimilate</span></span>(<span>self, HMM, xx, yy)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="dapper.da_methods.particle.PFxN_EnKF"><code class="flex name class">
<span>class <span class="ident">PFxN_EnKF</span></span>
<span>(</span><span>N: int, Qs: float, xN: int, re_use: bool = True, wroot_max: float = 5.0, NER: float = 1.0, resampl: str = 'Sys')</span>
</code></dt>
<dd>
<div class="desc"><p>Particle filter with EnKF-based proposal, q.</p>
<p>Also employs xN duplication, as in PFxN.</p>
<p>Recall that the proposals:
Opt.: q_n(x) = c_n·N(x|x_n,Q
)·N(y|Hx,R)
(1)
EnKF: q_n(x) = c_n·N(x|x_n,bar{B})·N(y|Hx,R)
(2)
with c_n = p(y|x^{k-1}_n) being the composite proposal-analysis weight,
and with Q possibly from regularization (rather than actual model noise).</p>
<p>Here, we will use the posterior mean of (2) and cov of (1).
Or maybe we should use x_a^n distributed according to a sqrt update?</p></div>
<h3>Class variables</h3>
<dl>
<dt id="dapper.da_methods.particle.PFxN_EnKF.N"><code class="name">var <span class="ident">N</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN_EnKF.Qs"><code class="name">var <span class="ident">Qs</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN_EnKF.xN"><code class="name">var <span class="ident">xN</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN_EnKF.re_use"><code class="name">var <span class="ident">re_use</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN_EnKF.wroot_max"><code class="name">var <span class="ident">wroot_max</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN_EnKF.NER"><code class="name">var <span class="ident">NER</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN_EnKF.resampl"><code class="name">var <span class="ident">resampl</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN_EnKF.da_method"><code class="name">var <span class="ident">da_method</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dapper.da_methods.particle.PFxN_EnKF.assimilate"><code class="name flex">
<span>def <span class="ident">assimilate</span></span>(<span>self, HMM, xx, yy)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="dapper.da_methods.particle.PFxN"><code class="flex name class">
<span>class <span class="ident">PFxN</span></span>
<span>(</span><span>N: int, Qs: float, xN: int, re_use: bool = True, wroot_max: float = 5.0, NER: float = 1.0, resampl: str = 'Sys')</span>
</code></dt>
<dd>
<div class="desc"><p>Particle filter with buckshot duplication during analysis.</p>
<p>Idea: sample xN duplicates from each of the N kernels.
Let resampling reduce it to N.</p>
<p>Additional idea: employ w-adjustment to obtain N unique particles,
without jittering.</p></div>
<h3>Class variables</h3>
<dl>
<dt id="dapper.da_methods.particle.PFxN.N"><code class="name">var <span class="ident">N</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN.Qs"><code class="name">var <span class="ident">Qs</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN.xN"><code class="name">var <span class="ident">xN</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN.re_use"><code class="name">var <span class="ident">re_use</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN.wroot_max"><code class="name">var <span class="ident">wroot_max</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN.NER"><code class="name">var <span class="ident">NER</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN.resampl"><code class="name">var <span class="ident">resampl</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dapper.da_methods.particle.PFxN.da_method"><code class="name">var <span class="ident">da_method</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dapper.da_methods.particle.PFxN.assimilate"><code class="name flex">
<span>def <span class="ident">assimilate</span></span>(<span>self, HMM, xx, yy)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dapper.da_methods" href="index.html">dapper.da_methods</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dapper.da_methods.particle.trigger_resampling" href="#dapper.da_methods.particle.trigger_resampling">trigger_resampling</a></code></li>
<li><code><a title="dapper.da_methods.particle.reweight" href="#dapper.da_methods.particle.reweight">reweight</a></code></li>
<li><code><a title="dapper.da_methods.particle.raw_C12" href="#dapper.da_methods.particle.raw_C12">raw_C12</a></code></li>
<li><code><a title="dapper.da_methods.particle.mask_unique_of_sorted" href="#dapper.da_methods.particle.mask_unique_of_sorted">mask_unique_of_sorted</a></code></li>
<li><code><a title="dapper.da_methods.particle.auto_bandw" href="#dapper.da_methods.particle.auto_bandw">auto_bandw</a></code></li>
<li><code><a title="dapper.da_methods.particle.regularize" href="#dapper.da_methods.particle.regularize">regularize</a></code></li>
<li><code><a title="dapper.da_methods.particle.resample" href="#dapper.da_methods.particle.resample">resample</a></code></li>
<li><code><a title="dapper.da_methods.particle.sample_quickly_with" href="#dapper.da_methods.particle.sample_quickly_with">sample_quickly_with</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dapper.da_methods.particle.PartFilt" href="#dapper.da_methods.particle.PartFilt">PartFilt</a></code></h4>
<ul class="two-column">
<li><code><a title="dapper.da_methods.particle.PartFilt.assimilate" href="#dapper.da_methods.particle.PartFilt.assimilate">assimilate</a></code></li>
<li><code><a title="dapper.da_methods.particle.PartFilt.N" href="#dapper.da_methods.particle.PartFilt.N">N</a></code></li>
<li><code><a title="dapper.da_methods.particle.PartFilt.reg" href="#dapper.da_methods.particle.PartFilt.reg">reg</a></code></li>
<li><code><a title="dapper.da_methods.particle.PartFilt.nuj" href="#dapper.da_methods.particle.PartFilt.nuj">nuj</a></code></li>
<li><code><a title="dapper.da_methods.particle.PartFilt.qroot" href="#dapper.da_methods.particle.PartFilt.qroot">qroot</a></code></li>
<li><code><a title="dapper.da_methods.particle.PartFilt.wroot" href="#dapper.da_methods.particle.PartFilt.wroot">wroot</a></code></li>
<li><code><a title="dapper.da_methods.particle.PartFilt.NER" href="#dapper.da_methods.particle.PartFilt.NER">NER</a></code></li>
<li><code><a title="dapper.da_methods.particle.PartFilt.resampl" href="#dapper.da_methods.particle.PartFilt.resampl">resampl</a></code></li>
<li><code><a title="dapper.da_methods.particle.PartFilt.da_method" href="#dapper.da_methods.particle.PartFilt.da_method">da_method</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dapper.da_methods.particle.OptPF" href="#dapper.da_methods.particle.OptPF">OptPF</a></code></h4>
<ul class="two-column">
<li><code><a title="dapper.da_methods.particle.OptPF.assimilate" href="#dapper.da_methods.particle.OptPF.assimilate">assimilate</a></code></li>
<li><code><a title="dapper.da_methods.particle.OptPF.N" href="#dapper.da_methods.particle.OptPF.N">N</a></code></li>
<li><code><a title="dapper.da_methods.particle.OptPF.Qs" href="#dapper.da_methods.particle.OptPF.Qs">Qs</a></code></li>
<li><code><a title="dapper.da_methods.particle.OptPF.reg" href="#dapper.da_methods.particle.OptPF.reg">reg</a></code></li>
<li><code><a title="dapper.da_methods.particle.OptPF.nuj" href="#dapper.da_methods.particle.OptPF.nuj">nuj</a></code></li>
<li><code><a title="dapper.da_methods.particle.OptPF.wroot" href="#dapper.da_methods.particle.OptPF.wroot">wroot</a></code></li>
<li><code><a title="dapper.da_methods.particle.OptPF.NER" href="#dapper.da_methods.particle.OptPF.NER">NER</a></code></li>
<li><code><a title="dapper.da_methods.particle.OptPF.resampl" href="#dapper.da_methods.particle.OptPF.resampl">resampl</a></code></li>
<li><code><a title="dapper.da_methods.particle.OptPF.da_method" href="#dapper.da_methods.particle.OptPF.da_method">da_method</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dapper.da_methods.particle.PFa" href="#dapper.da_methods.particle.PFa">PFa</a></code></h4>
<ul class="two-column">
<li><code><a title="dapper.da_methods.particle.PFa.assimilate" href="#dapper.da_methods.particle.PFa.assimilate">assimilate</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFa.N" href="#dapper.da_methods.particle.PFa.N">N</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFa.alpha" href="#dapper.da_methods.particle.PFa.alpha">alpha</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFa.reg" href="#dapper.da_methods.particle.PFa.reg">reg</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFa.nuj" href="#dapper.da_methods.particle.PFa.nuj">nuj</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFa.qroot" href="#dapper.da_methods.particle.PFa.qroot">qroot</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFa.NER" href="#dapper.da_methods.particle.PFa.NER">NER</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFa.resampl" href="#dapper.da_methods.particle.PFa.resampl">resampl</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFa.da_method" href="#dapper.da_methods.particle.PFa.da_method">da_method</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dapper.da_methods.particle.PFxN_EnKF" href="#dapper.da_methods.particle.PFxN_EnKF">PFxN_EnKF</a></code></h4>
<ul class="two-column">
<li><code><a title="dapper.da_methods.particle.PFxN_EnKF.assimilate" href="#dapper.da_methods.particle.PFxN_EnKF.assimilate">assimilate</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN_EnKF.N" href="#dapper.da_methods.particle.PFxN_EnKF.N">N</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN_EnKF.Qs" href="#dapper.da_methods.particle.PFxN_EnKF.Qs">Qs</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN_EnKF.xN" href="#dapper.da_methods.particle.PFxN_EnKF.xN">xN</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN_EnKF.re_use" href="#dapper.da_methods.particle.PFxN_EnKF.re_use">re_use</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN_EnKF.wroot_max" href="#dapper.da_methods.particle.PFxN_EnKF.wroot_max">wroot_max</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN_EnKF.NER" href="#dapper.da_methods.particle.PFxN_EnKF.NER">NER</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN_EnKF.resampl" href="#dapper.da_methods.particle.PFxN_EnKF.resampl">resampl</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN_EnKF.da_method" href="#dapper.da_methods.particle.PFxN_EnKF.da_method">da_method</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dapper.da_methods.particle.PFxN" href="#dapper.da_methods.particle.PFxN">PFxN</a></code></h4>
<ul class="two-column">
<li><code><a title="dapper.da_methods.particle.PFxN.assimilate" href="#dapper.da_methods.particle.PFxN.assimilate">assimilate</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN.N" href="#dapper.da_methods.particle.PFxN.N">N</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN.Qs" href="#dapper.da_methods.particle.PFxN.Qs">Qs</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN.xN" href="#dapper.da_methods.particle.PFxN.xN">xN</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN.re_use" href="#dapper.da_methods.particle.PFxN.re_use">re_use</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN.wroot_max" href="#dapper.da_methods.particle.PFxN.wroot_max">wroot_max</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN.NER" href="#dapper.da_methods.particle.PFxN.NER">NER</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN.resampl" href="#dapper.da_methods.particle.PFxN.resampl">resampl</a></code></li>
<li><code><a title="dapper.da_methods.particle.PFxN.da_method" href="#dapper.da_methods.particle.PFxN.da_method">da_method</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>
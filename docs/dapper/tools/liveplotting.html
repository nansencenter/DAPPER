<!-- Search file for "CHANGE" for my own changes -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dapper.tools.liveplotting API documentation</title>
<meta name="description" content="On-line (live) plots of the DA process for various models and methods â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://www.google.com">
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>
.gsc-control-cse {padding:0 !important;margin-top:1em}
body.gsc-overflow-hidden #sidebar {overflow: visible;}
</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="https://raw.githubusercontent.com/nansencenter/DAPPER/master/docs/imgs/logo.png">
<!-- Dont work coz pdoc already defines these:
<title>DAPPER doc</title>
<meta name="description" content="Data Assimilation with Python: a Package for Experimental Research" />
-->
<a href="https://github.com/nansencenter/DAPPER" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dapper.tools.liveplotting</code></h1>
</header>
<section id="section-intro">
<p>On-line (live) plots of the DA process for various models and methods.</p>
<p>Liveplotters are given by a list of tuples as property or arguments in
<code><a title="dapper.mods.HiddenMarkovModel" href="../mods/index.html#dapper.mods.HiddenMarkovModel">HiddenMarkovModel</a></code>.</p>
<ul>
<li>
<p>The first element of the tuple determines whether the liveplotter is shown if
the names of liveplotters are not given by <code>liveplots</code> argument in
<code>assimilate</code>.</p>
</li>
<li>
<p>The second element in the tuple gives the corresponding liveplotter
function/class. See example of function <code>LPs</code> in <code><a title="dapper.mods.Lorenz63" href="../mods/Lorenz63/index.html">dapper.mods.Lorenz63</a></code>.</p>
</li>
</ul>
<p>The liveplotters can be fine-tuned by each DA experiments via argument of
<code>liveplots</code> when calling <code>assimilate</code>.</p>
<ul>
<li>
<p><code>liveplots = True</code> turns on liveplotters set to default in the first
argument of the <code>HMM.liveplotter</code> and default liveplotters defined in this module
(<code><a title="dapper.tools.liveplotting.sliding_diagnostics" href="#dapper.tools.liveplotting.sliding_diagnostics">sliding_diagnostics</a></code> and <code><a title="dapper.tools.liveplotting.weight_histogram" href="#dapper.tools.liveplotting.weight_histogram">weight_histogram</a></code>).</p>
</li>
<li>
<p><code>liveplots</code> can also be a list of specified names of liveplotter, which
is the name of the corresponding liveplotting classes/functions.</p>
</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L0-L1345" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;On-line (live) plots of the DA process for various models and methods.

Liveplotters are given by a list of tuples as property or arguments in
`dapper.mods.HiddenMarkovModel`.

- The first element of the tuple determines whether the liveplotter is shown if
the names of liveplotters are not given by `liveplots` argument in
`assimilate`.

- The second element in the tuple gives the corresponding liveplotter
function/class. See example of function `LPs` in `dapper.mods.Lorenz63`.

The liveplotters can be fine-tuned by each DA experiments via argument of
`liveplots` when calling `assimilate`.

- `liveplots = True` turns on liveplotters set to default in the first
argument of the `HMM.liveplotter` and default liveplotters defined in this module
(`sliding_diagnostics` and `weight_histogram`).

- `liveplots` can also be a list of specified names of liveplotter, which
is the name of the corresponding liveplotting classes/functions.
&#34;&#34;&#34;

import matplotlib as mpl
import numpy as np
import scipy.linalg as sla
from matplotlib import pyplot as plt
from matplotlib.ticker import MaxNLocator
from mpl_toolkits.mplot3d.art3d import juggle_axes
from mpl_tools import is_notebook_or_qt, place, place_ax
from numpy import arange, nan, ones
from struct_tools import DotDict, deep_getattr

import dapper.tools.progressbar as pb
import dapper.tools.viz as viz
from dapper.dpr_config import rc
from dapper.mods.utils import linspace_int
from dapper.tools.chronos import format_time
from dapper.tools.matrices import CovMat
from dapper.tools.progressbar import read1
from dapper.tools.series import FAUSt, RollingArray
from dapper.tools.viz import not_available_text, plot_pause


class LivePlot:
    &#34;&#34;&#34;Live plotting manager.

    Deals with

    - Pause, skip.
    - Which liveploters to call.
    - `plot_u`
    - Figure window (title and number).
    &#34;&#34;&#34;

    def __init__(self,
                 stats,
                 liveplots,
                 key0=(0, None, &#39;u&#39;),
                 E=None,
                 P=None,
                 speed=1.0,
                 replay=False,
                 **kwargs):
        &#34;&#34;&#34;
        Initialize plots.

        - liveplots: figures to plot; alternatives:
            - `&#34;default&#34;/[]/True`: All default figures for this HMM.
            - `&#34;all&#34;`            : Even more.
            - non-empty `list`   : Only the figures with these numbers
                                 (int) or names (str).
            - `False`            : None.
        - speed: speed of animation.
            - `&gt;100`: instantaneous
            - `1`   : (default) as quick as possible allowing for
                      plt.draw() to work on a moderately fast computer.
            - `&lt;1`  : slower.
        &#34;&#34;&#34;
        # Disable if not rc.liveplotting
        self.any_figs = False
        if not rc.liveplotting:
            return

        # Determine whether all/universal/intermediate stats are plotted
        self.plot_u = not replay or stats.store_u

        # Set speed/pause params
        self.params = {
            &#39;pause_f&#39;: 0.05,
            &#39;pause_a&#39;: 0.05,
            &#39;pause_s&#39;: 0.05,
            &#39;pause_u&#39;: 0.001,
        }
        # If speed&gt;100: set to inf. Coz pause=1e-99 causes hangup.
        for pause in [&#34;pause_&#34;+x for x in &#34;faus&#34;]:
            speed = speed if speed &lt; 100 else np.inf
            self.params[pause] /= speed

        # Write params
        self.params.update(getattr(stats.xp, &#34;LP_kwargs&#34;, {}))
        self.params.update(kwargs)

        def get_name(init):
            &#34;&#34;&#34;Get name of liveplotter function/class.&#34;&#34;&#34;
            try:
                return init.__qualname__.split(&#34;.&#34;)[0]
            except AttributeError:
                return init.__class__.__name__

        # Set up dict of liveplotters
        potential_LPs = {}
        for show, init in default_liveplotters:
            potential_LPs[get_name(init)] = show, init
        # Add HMM-specific liveplotters
        for show, init in getattr(stats.HMM, &#39;liveplotters&#39;, {}):
            potential_LPs[get_name(init)] = show, init

        def parse_figlist(lst):
            &#34;&#34;&#34;Figures requested for this xp. Convert to list.&#34;&#34;&#34;
            if isinstance(lst, str):
                fn = lst.lower()
                if &#34;all&#34; == fn:
                    lst = [&#34;all&#34;]  # All potential_LPs
                elif &#34;default&#34; in fn:
                    lst = [&#34;default&#34;]         # All show_by_default
            elif hasattr(lst, &#39;__len__&#39;):
                lst = lst            # This list (only)
            elif lst:
                lst = [&#34;default&#34;]             # All show_by_default
            else:
                lst = [None]         # None
            return lst
        figlist = parse_figlist(liveplots)

        # Loop over requeted figures
        self.figures = {}
        for name, (show_by_default, init) in potential_LPs.items():
            if (figlist == [&#34;all&#34;]) or \
                    (name in figlist) or \
                    (figlist == [&#34;default&#34;] and show_by_default):

                # Startup message
                if not self.any_figs:
                    print(&#39;Initializing liveplots...&#39;)
                    if is_notebook_or_qt:
                        pauses = [self.params[&#34;pause_&#34; + x] for x in &#34;faus&#34;]
                        if any((p &gt; 0) for p in pauses):
                            print(&#34;Note: liveplotting does not work very well&#34;
                                  &#34; inside Jupyter notebooks. In particular,&#34;
                                  &#34; there is no way to stop/skip them except&#34;
                                  &#34; to interrupt the kernel (the stop button&#34;
                                  &#34; in the toolbar). Consider using instead&#34;
                                  &#34; only the replay functionality (with infinite&#34;
                                  &#34; playback speed).&#34;)
                    elif not pb.disable_user_interaction:
                        print(&#39;Hit &lt;Space&gt; to pause/step.&#39;)
                        print(&#39;Hit &lt;Enter&gt; to resume/skip.&#39;)
                        print(&#39;Hit &lt;i&gt; to enter debug mode.&#39;)
                    self.paused = False
                    self.run_ipdb = False
                    self.skipping = False
                    self.any_figs = True

                # Init figure
                post_title = &#34;&#34; if self.plot_u else &#34;\n(obs times only)&#34;
                updater = init(name, stats, key0, self.plot_u, E, P, **kwargs)
                if plt.fignum_exists(name) and getattr(updater, &#39;is_active&#39;, 1):
                    self.figures[name] = updater
                    fig = plt.figure(name)
                    win = fig.canvas
                    ax0 = fig.axes[0]
                    win.manager.set_window_title(&#34;%s&#34; % name)
                    ax0.set_title(ax0.get_title() + post_title)
                    self.update(key0, E, P)  # Call initial update
                    plt.pause(0.01)          # Draw

    def update(self, key, E, P):
        &#34;&#34;&#34;Update liveplots&#34;&#34;&#34;
        # Check if there are still open figures
        if self.any_figs:
            open_figns = plt.get_figlabels()
            live_figns = set(self.figures.keys())
            self.any_figs = bool(live_figns.intersection(open_figns))
        else:
            return

        # Playback control
        SPACE  = b&#39; &#39;
        CHAR_I = b&#39;i&#39;
        ENTERs = [b&#39;\n&#39;, b&#39;\r&#39;]  # Linux + Windows

        def pause():
            &#34;&#34;&#34;Loop until user decision is made.&#34;&#34;&#34;
            ch = read1()
            while True:
                # Set state (pause, skipping, ipdb)
                if ch in ENTERs:
                    self.paused = False
                elif ch == CHAR_I:
                    self.run_ipdb = True
                # If keypress valid, resume execution
                if ch in ENTERs + [SPACE, CHAR_I]:
                    break
                ch = read1()
                # Pause to enable zoom, pan, etc. of mpl GUI
                plot_pause(0.01)  # Don&#39;t use time.sleep()!

        # Enter pause loop
        if self.paused:
            pause()

        else:
            if key == (0, None, &#39;u&#39;):
                # Skip read1 for key0 (coz it blocks)
                pass
            else:
                ch = read1()
                if ch == SPACE:
                    # Pause
                    self.paused = True
                    self.skipping = False
                    pause()
                elif ch in ENTERs:
                    # Toggle skipping
                    self.skipping = not self.skipping
                elif ch == CHAR_I:
                    # Schedule debug
                    # Note: The reason we dont set_trace(frame) right here is:
                    # - I could not find the right frame, even doing
                    #   &gt;   frame = inspect.stack()[0]
                    #   &gt;   while frame.f_code.co_name != &#34;assimilate&#34;:
                    #   &gt;       frame = frame.f_back
                    # - It just restarts the plot.
                    self.run_ipdb = True

        # Update figures
        if not self.skipping:
            faus = key[-1]
            if faus != &#39;u&#39; or self.plot_u:
                for name, (updater) in self.figures.items():
                    if plt.fignum_exists(name) and \
                            getattr(updater, &#39;is_active&#39;, 1):
                        _ = plt.figure(name)
                        updater(key, E, P)
                        plot_pause(self.params[&#39;pause_&#39;+faus])

        if self.run_ipdb:
            self.run_ipdb = False
            import inspect

            import ipdb
            print(&#34;Entering debug mode (ipdb).&#34;)
            print(&#34;Type &#39;?&#39; (and Enter) for usage help.&#34;)
            print(&#34;Type &#39;c&#39; to continue the assimilation.&#34;)
            ipdb.set_trace(inspect.stack()[2].frame)


# TODO 6:
# - iEnKS diagnostics don&#39;t work at all when store_u=False
star = &#34;${}^*$&#34;


class sliding_diagnostics:
    &#34;&#34;&#34;Plots a sliding window (like a heart rate monitor) of certain diagnostics.&#34;&#34;&#34;

    def __init__(self, fignum, stats, key0, plot_u,
                 E, P, Tplot=None, **kwargs):

        # STYLE TABLES - Defines which/how diagnostics get plotted
        styles = {}
        def lin(a, b): return (lambda x: a + b*x)
        divN = 1/getattr(stats.xp, &#39;N&#39;, 99)
        # Columns: transf, shape, plt kwargs
        styles[&#39;RMS&#39;] = {
            &#39;err.rms&#39;: [None, None, dict(c=&#39;k&#39;, label=&#39;Error&#39;)],
            &#39;std.rms&#39;: [None, None, dict(c=&#39;b&#39;, label=&#39;Spread&#39;, alpha=0.6)],
        }
        styles[&#39;Values&#39;] = {
            &#39;skew&#39;: [None, None, dict(c=&#39;g&#39;, label=star+r&#39;Skew/$\sigma^3$&#39;)],
            &#39;kurt&#39;: [None, None, dict(c=&#39;r&#39;, label=star+r&#39;Kurt$/\sigma^4{-}3$&#39;)],
            &#39;trHK&#39;: [None, None, dict(c=&#39;k&#39;, label=star+&#39;HK&#39;)],
            &#39;infl&#39;: [lin(-10, 10), &#39;step&#39;, dict(c=&#39;c&#39;, label=&#39;10(infl-1)&#39;)],
            &#39;N_eff&#39;: [lin(0, divN), &#39;dirac&#39;, dict(c=&#39;y&#39;, label=&#39;N_eff/N&#39;, lw=3)],
            &#39;iters&#39;: [lin(0, .1), &#39;dirac&#39;, dict(c=&#39;m&#39;, label=&#39;iters/10&#39;)],
            &#39;resmpl&#39;: [None, &#39;dirac&#39;, dict(c=&#39;k&#39;, label=&#39;resampled?&#39;)],
        }

        nAx = len(styles)
        GS = {&#39;left&#39;: 0.125, &#39;right&#39;: 0.76}
        fig, axs = place.freshfig(fignum, figsize=(5, 1+nAx),
                                  nrows=nAx, sharex=True, gridspec_kw=GS)

        axs[0].set_title(&#34;Diagnostics&#34;)
        for style, ax in zip(styles, axs):
            ax.set_ylabel(style)
        ax.set_xlabel(&#39;Time (t)&#39;)
        place_ax.adjust_position(ax, y0=0.03)

        self.T_lag, K_lag, a_lag = validate_lag(Tplot, stats.HMM.t)

        def init_ax(ax, style_table):
            lines = {}
            for name in style_table:

                # SKIP -- if stats[name] is not in existence
                # Note: The nan check/deletion comes after the first kObs.
                try:
                    stat = deep_getattr(stats, name)
                except AttributeError:
                    continue
                # try: val0 = stat[key0[0]]
                # except KeyError: continue
                # PS: recall (from series.py) that even if store_u is false, stat[k] is
                # still present if liveplots=True via the k_tmp functionality.

                # Unpack style
                ln = {}
                ln[&#39;transf&#39;] = style_table[name][0] or (lambda x: x)
                ln[&#39;shape&#39;]  = style_table[name][1]
                ln[&#39;plt&#39;]    = style_table[name][2]

                # Create series
                if isinstance(stat, FAUSt):
                    ln[&#39;plot_u&#39;] = plot_u
                    K_plot       = comp_K_plot(K_lag, a_lag, ln[&#39;plot_u&#39;])
                else:
                    ln[&#39;plot_u&#39;] = False
                    K_plot       = a_lag
                ln[&#39;data&#39;]   = RollingArray(K_plot)
                ln[&#39;tt&#39;]     = RollingArray(K_plot)

                # Plot (init)
                ln[&#39;handle&#39;], = ax.plot(ln[&#39;tt&#39;], ln[&#39;data&#39;], **ln[&#39;plt&#39;])

                # Plotting only nans yield ugly limits. Revert to defaults.
                ax.set_xlim(0, 1)
                ax.set_ylim(0, 1)

                lines[name] = ln
            return lines

        # Plot
        self.d = [init_ax(ax, styles[style]) for style, ax in zip(styles, axs)]

        # Horizontal line at y=0
        self.baseline0, = ax.plot(
            ax.get_xlim(), [0, 0], c=0.5*ones(3), lw=0.7, label=&#39;_nolegend_&#39;)

        # Store
        self.axs   = axs
        self.stats = stats
        self.init_incomplete = True

    # Update plot
    def __call__(self, key, E, P):
        k, kObs, faus = key

        stats  = self.stats
        chrono = stats.HMM.t
        ax0, ax1 = self.axs

        def update_arrays(lines):
            for name, ln in lines.items():
                stat = deep_getattr(stats, name)
                t    = chrono.tt[k]  # == chrono.ttObs[kObs]
                if isinstance(stat, FAUSt):
                    # ln[&#39;data&#39;] will contain duplicates for f/a times.
                    if ln[&#39;plot_u&#39;]:
                        val = stat[key]
                        ln[&#39;tt&#39;]  .insert(k, t)
                        ln[&#39;data&#39;].insert(k, ln[&#39;transf&#39;](val))
                    elif &#39;u&#39; not in faus:
                        val = stat[key]
                        ln[&#39;tt&#39;]  .insert(kObs, t)
                        ln[&#39;data&#39;].insert(kObs, ln[&#39;transf&#39;](val))
                else:
                    # ln[&#39;data&#39;] will not contain duplicates, coz only &#39;a&#39; is input.
                    if &#39;a&#39; in faus:
                        val = stat[kObs]
                        ln[&#39;tt&#39;]  .insert(kObs, t)
                        ln[&#39;data&#39;].insert(kObs, ln[&#39;transf&#39;](val))
                    elif &#39;f&#39; in faus:
                        pass

        def update_plot_data(ax, lines):

            def bend_into(shape, xx, yy):
                # Get arrays. Repeat (to use for intermediate nodes).
                yy = yy.array.repeat(3)
                xx = xx.array.repeat(3)
                if len(xx) == 0:
                    pass  # shortcircuit any modifications
                elif shape == &#39;step&#39;:
                    yy = np.hstack([yy[1:], nan])  # roll leftward
                elif shape == &#39;dirac&#39;:
                    nonlocal nDirac
                    axW      = np.diff(ax.get_xlim())
                    yy[0::3] = False           # set datapoin to 0
                    xx[2::3] = nan             # make datapoint disappear
                    xx      += nDirac*axW/100  # offset datapoint horizontally
                    nDirac  += 1
                return xx, yy

            nDirac = 1
            for _name, ln in lines.items():
                ln[&#39;handle&#39;].set_data(*bend_into(ln[&#39;shape&#39;], ln[&#39;tt&#39;], ln[&#39;data&#39;]))

        def finalize_init(ax, lines, mm):
            # Rm lines that only contain NaNs
            for name in list(lines):
                ln   = lines[name]
                stat = deep_getattr(stats, name)
                if not stat.were_changed:
                    ln[&#39;handle&#39;].remove()  # rm from axes
                    del lines[name]        # rm from dict
            # Add legends
            if lines:
                ax.legend(loc=&#39;upper left&#39;,
                          bbox_to_anchor=(1.01, 1), borderaxespad=0)
                if mm:
                    ax.annotate(star+&#34;: mean of\nmarginals&#34;,
                                xy=(0, -1.5/len(lines)),
                                xycoords=ax.get_legend().get_frame(),
                                bbox=dict(alpha=0.0), fontsize=&#39;small&#39;)
            # coz placement of annotate needs flush sometimes:
            plot_pause(0.01)

        # Insert current stats
        for lines, ax in zip(self.d, self.axs):
            update_arrays(lines)
            update_plot_data(ax, lines)

        # Set x-limits (time)
        sliding_xlim(ax0, self.d[0][&#39;err.rms&#39;][&#39;tt&#39;], self.T_lag, margin=True)
        self.baseline0.set_xdata(ax0.get_xlim())

        # Set y-limits
        data0 = [ln[&#39;data&#39;].array for ln in self.d[0].values()]
        data1 = [ln[&#39;data&#39;].array for ln in self.d[1].values()]
        ax0.set_ylim(0, d_ylim(data0, ax0             , cC=0.2, cE=0.9)[1])
        ax1.set_ylim(*d_ylim(data1, ax1, Max=4, Min=-4, cC=0.3, cE=0.9))

        # Init legend. Rm nan lines.
        if self.init_incomplete and &#39;a&#39; == faus:
            self.init_incomplete = False
            finalize_init(ax0, self.d[0], False)
            finalize_init(ax1, self.d[1], True)


def sliding_xlim(ax, tt, lag, margin=False):
    dt = lag/20 if margin else 0
    if tt.nFilled == 0:
        return  # Quit
    t1, t2 = tt.span()      # Get suggested span.
    s1, s2 = ax.get_xlim()  # Get previous lims.
    # If zero span (eg tt holds single &#39;f&#39; and &#39;a&#39;):
    if t1 == t2:
        t1 -= 1  # add width
        t2 += 1  # add width
    # If user has skipped (too much):
    elif np.isnan(t1):
        s2    -= dt     # Correct for dt.
        span   = s2-s1  # Compute previous span
        # If span&lt;lag:
        if span &lt; lag:
            span  += (t2-s2)  # Grow by &#34;dt&#34;.
        span   = min(lag, span)  # Bound
        t1     = t2 - span       # Set span.
    ax.set_xlim(t1, t2 + dt)  # Set xlim to span


class weight_histogram:
    &#34;&#34;&#34;Plots histogram of weights. Refreshed each analysis.&#34;&#34;&#34;

    def __init__(self, fignum, stats, key0, plot_u, E, P, **kwargs):
        if not hasattr(stats, &#39;w&#39;):
            self.is_active = False
            return
        fig, ax = place.freshfig(fignum, figsize=(7, 3), gridspec_kw={&#39;bottom&#39;: .15})

        ax.set_xscale(&#39;log&#39;)
        ax.set_xlabel(&#39;Weigth&#39;)
        ax.set_ylabel(&#39;Count&#39;)
        self.stats = stats
        self.ax    = ax
        self.hist  = []
        self.bins  = np.exp(np.linspace(np.log(1e-10), np.log(1), 31))

    def __call__(self, key, E, P):
        k, kObs, faus = key
        if &#39;a&#39; == faus:
            w  = self.stats.w[key]
            N  = len(w)
            ax = self.ax

            self.is_active = N &lt; 10001
            if not self.is_active:
                not_available_text(ax, &#39;Not computed (N &gt; threshold)&#39;)
                return

            counted = w &gt; self.bins[0]
            _ = [b.remove() for b in self.hist]
            nn, _, self.hist = ax.hist(
                w[counted], bins=self.bins, color=&#39;b&#39;)
            ax.set_ylim(top=max(nn))

            ax.set_title(&#39;N: {:d}.   N_eff: {:.4g}.   Not shown: {:d}. &#39;.
                         format(N, 1/(w@w), N-np.sum(counted)))


class spectral_errors:
    &#34;&#34;&#34;Plots the (spatial-RMS) error as a functional of the SVD index.&#34;&#34;&#34;

    def __init__(self, fignum, stats, key0, plot_u, E, P, **kwargs):
        fig, ax = place.freshfig(fignum, figsize=(6, 3))
        ax.set_xlabel(&#39;Sing. value index&#39;)
        ax.set_yscale(&#39;log&#39;)
        self.init_incomplete = True
        self.ax = ax
        self.plot_u = plot_u

        try:
            self.msft = stats.umisf
            self.sprd = stats.svals
        except AttributeError:
            self.is_active = False
            not_available_text(ax, &#34;Spectral stats not being computed&#34;)

    # Update plot
    def __call__(self, key, E, P):
        k, kObs, faus = key
        ax = self.ax
        if self.init_incomplete:
            if self.plot_u or &#39;f&#39; == faus:
                self.init_incomplete = False
                msft = abs(self.msft[key])
                sprd = self.sprd[key]
                if np.any(np.isinf(msft)):
                    not_available_text(ax, &#34;Spectral stats not finite&#34;)
                    self.is_active = False
                else:
                    self.line_msft, = ax.plot(
                        msft, &#39;k&#39;, lw=2, label=&#39;Error&#39;)
                    self.line_sprd, = ax.plot(
                        sprd, &#39;b&#39;, lw=2, label=&#39;Spread&#39;, alpha=0.9)
                    ax.get_xaxis().set_major_locator(
                        MaxNLocator(integer=True))
                    ax.legend()
        else:
            msft = abs(self.msft[key])
            sprd = self.sprd[key]
            self.line_sprd.set_ydata(sprd)
            self.line_msft.set_ydata(msft)
        # ax.set_ylim(*d_ylim(msft))
        # ax.set_ylim(bottom=1e-5)
        ax.set_ylim([1e-3, 1e1])


class correlations:
    &#34;&#34;&#34;Plots the state (auto-)correlation matrix.&#34;&#34;&#34;

    half = True  # Whether to show half/full (symmetric) corr matrix.

    def __init__(self, fignum, stats, key0, plot_u, E, P, **kwargs):

        GS = {&#39;height_ratios&#39;: [4, 1], &#39;hspace&#39;: 0.09, &#39;top&#39;: 0.95}
        fig, (ax, ax2) = place.freshfig(fignum, figsize=(5, 6), nrows=2, gridspec_kw=GS)

        if E is None and np.isnan(
                P.diag if isinstance(P, CovMat) else P).all():
            not_available_text(ax, (
                &#39;Not available in replays&#39;
                &#39;\ncoz full Ens/Cov not stored.&#39;))
            self.is_active = False
            return

        Nx = len(stats.mu[key0])
        if Nx &lt;= 1003:
            C = np.eye(Nx)
            # Mask half
            mask = np.zeros_like(C, dtype=np.bool)
            mask[np.tril_indices_from(mask)] = True
            # Make colormap. Log-transform cmap,
            # but not internally in matplotlib,
            # so as to avoid transforming the colorbar too.
            cmap = plt.get_cmap(&#39;RdBu_r&#39;)
            trfm = mpl.colors.SymLogNorm(linthresh=0.2, linscale=0.2,
                                         base=np.e, vmin=-1, vmax=1)
            cmap = cmap(trfm(np.linspace(-0.6, 0.6, cmap.N)))
            cmap = mpl.colors.ListedColormap(cmap)
            #
            VM   = 1.0  # abs(np.percentile(C,[1,99])).max()
            im   = ax.imshow(C, cmap=cmap, vmin=-VM, vmax=VM)
            # Colorbar
            _ = ax.figure.colorbar(im, ax=ax, shrink=0.8)
            # Tune plot
            plt.box(False)
            ax.set_facecolor(&#39;w&#39;)
            ax.grid(False)
            ax.set_title(&#34;State correlation matrix:&#34;, y=1.07)
            ax.xaxis.tick_top()

            # ax2 = inset_axes(ax,width=&#34;30%&#34;,height=&#34;60%&#34;,loc=3)
            line_AC, = ax2.plot(arange(Nx), ones(Nx), label=&#39;Correlation&#39;)
            line_AA, = ax2.plot(arange(Nx), ones(Nx), label=&#39;Abs. corr.&#39;)
            _        = ax2.hlines(0, 0, Nx-1, &#39;k&#39;, &#39;dotted&#39;, lw=1)
            # Align ax2 with ax
            bb_AC = ax2.get_position()
            bb_C  = ax.get_position()
            ax2.set_position([bb_C.x0, bb_AC.y0, bb_C.width, bb_AC.height])
            # Tune plot
            ax2.set_title(&#34;Auto-correlation:&#34;)
            ax2.set_ylabel(&#34;Mean value&#34;)
            ax2.set_xlabel(&#34;Distance (in state indices)&#34;)
            ax2.set_xticklabels([])
            ax2.set_yticks([0, 1] + list(ax2.get_yticks()[[0, -1]]))
            ax2.set_ylim(top=1)
            ax2.legend(frameon=True, facecolor=&#39;w&#39;,
                       bbox_to_anchor=(1, 1), loc=&#39;upper left&#39;, borderaxespad=0.02)

            self.ax      = ax
            self.ax2     = ax2
            self.im      = im
            self.line_AC = line_AC
            self.line_AA = line_AA
            self.mask    = mask
            if hasattr(stats, &#39;w&#39;):
                self.w   = stats.w
        else:
            not_available_text(ax)

    # Update plot
    def __call__(self, key, E, P):
        # Get cov matrix
        if E is not None:
            if hasattr(self, &#39;w&#39;):
                C = np.cov(E, rowvar=False, aweights=self.w[key])
            else:
                C = np.cov(E, rowvar=False)
        else:
            assert P is not None
            C = P.full if isinstance(P, CovMat) else P
            C = C.copy()
        # Compute corr from cov
        std = np.sqrt(np.diag(C))
        C  /= std[:, None]
        C  /= std[None, :]
        # Mask
        if self.half:
            C = np.ma.masked_where(self.mask, C)
        # Plot
        self.im.set_data(C)
        # Auto-corr function
        ACF = circulant_ACF(C)
        AAF = circulant_ACF(C, do_abs=True)
        self.line_AC.set_ydata(ACF)
        self.line_AA.set_ydata(AAF)


def circulant_ACF(C, do_abs=False):
    &#34;&#34;&#34;Compute the auto-covariance-function corresponding to `C`.

    This assumes it is the cov/corr matrix of a 1D periodic domain.
    &#34;&#34;&#34;
    M = len(C)
    # cols = np.flipud(sla.circulant(np.arange(M)[::-1]))
    cols = sla.circulant(np.arange(M))
    ACF = np.zeros(M)
    for i in range(M):
        row = C[i, cols[i]]
        if do_abs:
            row = abs(row)
        ACF += row
        # Note: this actually also accesses masked values in C.
    return ACF/M


def sliding_marginals(
    obs_inds     = (),
    dims         = (),
    labels       = (),
    Tplot        = None,
    ens_props    = dict(alpha=0.4),  # noqa
    zoomy        = 1.0,
):

    # Store parameters
    params_orig = DotDict(**locals())

    def init(fignum, stats, key0, plot_u, E, P, **kwargs):
        xx, yy, mu, std, chrono = \
            stats.xx, stats.yy, stats.mu, stats.std, stats.HMM.t

        # Set parameters (kwargs takes precedence over params_orig)
        p = DotDict(**{
            kw: kwargs.get(kw, val) for kw, val in params_orig.items()})

        # Lag settings:
        T_lag, K_lag, a_lag = validate_lag(p.Tplot, chrono)
        K_plot = comp_K_plot(K_lag, a_lag, plot_u)
        # Extend K_plot forther for adding blanks in resampling (PartFilt):
        has_w = hasattr(stats, &#39;w&#39;)
        if has_w:
            K_plot += a_lag

        # Chose marginal dims to plot
        if not p.dims:
            Nx      = min(10, xx.shape[-1])
            DimsX   = linspace_int(xx.shape[-1], Nx)
        else:
            Nx      = len(p.dims)
            DimsX   = p.dims
        # Pre-process obs dimensions
        # Rm inds of obs if not in DimsX
        iiY   = [i for i, m in enumerate(p.obs_inds) if m in DimsX]
        # Rm obs_inds    if not in DimsX
        DimsY = [m for i, m in enumerate(p.obs_inds) if m in DimsX]
        # Get dim (within y) of each x
        DimsY = [DimsY.index(m) if m in DimsY else None for m in DimsX]
        Ny    = len(iiY)

        # Set up figure, axes
        fig, axs = place.freshfig(fignum, figsize=(5, 7), nrows=Nx, sharex=True)
        if Nx == 1:
            axs = [axs]

        # Tune plots
        axs[0].set_title(&#34;Marginal time series&#34;)
        for ix, (m, ax) in enumerate(zip(DimsX, axs)):
            # ax.set_ylim(*viz.stretch(*viz.xtrema(xx[:, m]), 1/p.zoomy))
            if not p.labels:
                ax.set_ylabel(&#34;$x_{%d}$&#34; % m)
            else:
                ax.set_ylabel(p.labels[ix])
        axs[-1].set_xlabel(&#39;Time (t)&#39;)

        plot_pause(0.05)
        plt.tight_layout()

        # Allocate
        d = DotDict()  # data arrays
        h = DotDict()  # plot handles
        # Why &#34;if True&#34; ? Just to indent the rest of the line...
        if True:
            d.t  = RollingArray((K_plot,))
        if True:
            d.x  = RollingArray((K_plot, Nx))
            h.x  = []
        if True:
            d.y  = RollingArray((K_plot, Ny))
            h.y  = []
        if E is not None:
            d.E  = RollingArray((K_plot, len(E), Nx))
            h.E  = []
        if P is not None:
            d.mu = RollingArray((K_plot, Nx))
            h.mu = []
        if P is not None:
            d.s  = RollingArray((K_plot, 2, Nx))
            h.s  = []

        # Plot (invisible coz everything here is nan, for the moment).
        for ix, (_m, iy, ax) in enumerate(zip(DimsX, DimsY, axs)):
            if True:
                h.x  += ax.plot(d.t, d.x[:, ix], &#39;k&#39;)
            if iy != None:
                h.y  += ax.plot(d.t, d.y[:, iy], &#39;g*&#39;, ms=10)
            if &#39;E&#39; in d:
                h.E  += [ax.plot(d.t, d.E[:, :, ix], **p.ens_props)]
            if &#39;mu&#39; in d:
                h.mu += ax.plot(d.t, d.mu[:, ix], &#39;b&#39;)
            if &#39;s&#39; in d:
                h.s  += [ax.plot(d.t, d.s[:, :, ix], &#39;b--&#39;, lw=1)]

        def update(key, E, P):
            k, kObs, faus = key

            EE = duplicate_with_blanks_for_resampled(E, DimsX, key, has_w)

            # Roll data array
            ind = k if plot_u else kObs
            for Ens in EE:  # If E is duplicated, so must the others be.
                if &#39;E&#39; in d:
                    d.E .insert(ind, Ens)
                if &#39;mu&#39; in d:
                    d.mu.insert(ind, mu[key][DimsX])
                if &#39;s&#39; in d:
                    d.s .insert(ind, mu[key][DimsX] + [[1], [-1]]*std[key][DimsX])
                if True:
                    d.t .insert(ind, chrono.tt[k])
                if True:
                    d.y .insert(ind, yy[kObs, iiY]
                                if kObs is not None else nan*ones(Ny))
                if True:
                    d.x .insert(ind, xx[k, DimsX])

            # Update graphs
            for ix, (_m, iy, ax) in enumerate(zip(DimsX, DimsY, axs)):
                sliding_xlim(ax, d.t, T_lag, True)
                if True:
                    h.x[ix]    .set_data(d.t, d.x[:, ix])
                if iy != None:
                    h.y[iy]    .set_data(d.t, d.y[:, iy])
                if &#39;mu&#39; in d:
                    h.mu[ix]   .set_data(d.t, d.mu[:, ix])
                if &#39;s&#39; in d:
                    [h.s[ix][b].set_data(d.t, d.s[:, b, ix]) for b in [0, 1]]
                if &#39;E&#39; in d:
                    [h.E[ix][n].set_data(d.t, d.E[:, n, ix]) for n in range(len(E))]
                if &#39;E&#39; in d:
                    update_alpha(key, stats, h.E[ix])

                # TODO 3: fixup. This might be slow?
                # In any case, it is very far from tested.
                # Also, relim&#39;iting all of the time is distracting.
                # Use d_ylim?
                if &#39;E&#39; in d:
                    lims = d.E
                elif &#39;mu&#39; in d:
                    lims = d.mu
                lims = np.array(viz.xtrema(lims[..., ix]))
                if lims[0] == lims[1]:
                    lims += [-.5, +.5]
                ax.set_ylim(*viz.stretch(*lims, 1/p.zoomy))

            return
        return update
    return init


def phase_particles(
    is_3d        = True,
    obs_inds     = (),
    dims         = (),
    labels       = (),
    Tplot        = None,
    ens_props    = dict(alpha=0.4),  # noqa
    zoom         = 1.5,
):

    # Store parameters
    params_orig = DotDict(**locals())

    M = 3 if is_3d else 2

    def init(fignum, stats, key0, plot_u, E, P, **kwargs):
        xx, yy, mu, _, chrono = \
            stats.xx, stats.yy, stats.mu, stats.std, stats.HMM.t

        # Set parameters (kwargs takes precedence over params_orig)
        p = DotDict(**{
            kw: kwargs.get(kw, val) for kw, val in params_orig.items()})

        # Lag settings:
        has_w = hasattr(stats, &#39;w&#39;)
        if p.Tplot == 0:
            K_plot = 1
        else:
            T_lag, K_lag, a_lag = validate_lag(p.Tplot, chrono)
            K_plot = comp_K_plot(K_lag, a_lag, plot_u)
            # Extend K_plot forther for adding blanks in resampling (PartFilt):
            if has_w:
                K_plot += a_lag

        # Dimension settings
        if not p.dims:
            p.dims   = arange(M)
        if not p.labels:
            p.labels = [&#34;$x_%d$&#34; % d for d in p.dims]
        assert len(p.dims) == M

        # Set up figure, axes
        fig, _ = place.freshfig(fignum, figsize=(5, 5))
        ax = plt.subplot(111, projection=&#39;3d&#39; if is_3d else None)
        ax.set_facecolor(&#39;w&#39;)
        ax.set_title(&#34;Phase space trajectories&#34;)
        # Tune plot
        for ind, (s, i, t) in enumerate(zip(p.labels, p.dims, &#34;xyz&#34;)):
            viz.set_ilim(ax, ind, *viz.stretch(*viz.xtrema(xx[:, i]), 1/p.zoom))
            eval(&#34;ax.set_%slabel(&#39;%s&#39;)&#34; % (t, s))

        # Allocate
        d = DotDict()  # data arrays
        h = DotDict()  # plot handles
        s = DotDict()  # scatter handles
        if E is not None:
            d.E  = RollingArray((K_plot, len(E), M))
            h.E = []
        if P is not None:
            d.mu = RollingArray((K_plot, M))
        if True:
            d.x  = RollingArray((K_plot, M))
        if list(p.obs_inds) == list(p.dims):
            d.y  = RollingArray((K_plot, M))

        # Plot tails (invisible coz everything here is nan, for the moment).
        if &#39;E&#39; in d:
            h.E  += [ax.plot(*xn, **p.ens_props)[0]
                     for xn in np.transpose(d.E, [1, 2, 0])]
        if &#39;mu&#39; in d:
            h.mu  = ax.plot(*d.mu.T, &#39;b&#39;, lw=2)[0]
        if True:
            h.x   = ax.plot(*d.x .T, &#39;k&#39;, lw=3)[0]
        if &#39;y&#39; in d:
            h.y   = ax.plot(*d.y .T, &#39;g*&#39;, ms=14)[0]

        # Scatter. NB: don&#39;t init with nan&#39;s coz it&#39;s buggy
        # (wrt. get_color() and _offsets3d) since mpl 3.1.
        if &#39;E&#39; in d:
            s.E   = ax.scatter(*E.T[p.dims], s=3**2,
                               c=[hn.get_color() for hn in h.E])
        if &#39;mu&#39; in d:
            s.mu  = ax.scatter(*ones(M), s=8**2,
                               c=[h.mu.get_color()])
        if True:
            s.x  = ax.scatter(*ones(M), s=14**2,
                              c=[h.x.get_color()], marker=(5, 1), zorder=99)

        def update(key, E, P):
            k, kObs, faus = key
            show_y = &#39;y&#39; in d and kObs is not None

            def update_tail(handle, newdata):
                handle.set_data(newdata[:, 0], newdata[:, 1])
                if is_3d:
                    handle.set_3d_properties(newdata[:, 2])

            def update_sctr(handle, newdata):
                if is_3d:
                    handle._offsets3d = juggle_axes(*newdata.T, &#39;z&#39;)
                else:
                    handle.set_offsets(newdata)

            EE = duplicate_with_blanks_for_resampled(E, p.dims, key, has_w)

            # Roll data array
            ind = k if plot_u else kObs
            for Ens in EE:  # If E is duplicated, so must the others be.
                if &#39;E&#39; in d:
                    d.E .insert(ind, Ens)
                if True:
                    d.x .insert(ind, xx[k, p.dims])
                if &#39;y&#39; in d:
                    d.y .insert(ind, yy[kObs, :] if show_y else nan*ones(M))
                if &#39;mu&#39; in d:
                    d.mu.insert(ind, mu[key][p.dims])

            # Update graph
            update_sctr(s.x, d.x[[-1]])
            update_tail(h.x, d.x)
            if &#39;y&#39; in d:
                update_tail(h.y, d.y)
            if &#39;mu&#39; in d:
                update_sctr(s.mu, d.mu[[-1]])
                update_tail(h.mu, d.mu)
            else:
                update_sctr(s.E, d.E[-1])
                for n in range(len(E)):
                    update_tail(h.E[n], d.E[:, n, :])
                update_alpha(key, stats, h.E, s.E)

            return
        return update
    return init


def validate_lag(Tplot, chrono):
    &#34;&#34;&#34;Return validated `T_lag` such that is is:

    - equal to `Tplot` with fallback: `HMM.t.Tplot`.
    - no longer than `HMM.t.T`.

    Also return corresponding `K_lag`, `a_lag`.
    &#34;&#34;&#34;
    # Defaults
    if Tplot is None:
        Tplot = chrono.Tplot

    # Rename
    T_lag = Tplot

    assert T_lag &gt;= 0

    # Validate T_lag
    t2 = chrono.tt[-1]
    t1 = max(chrono.tt[0], t2-T_lag)
    T_lag = t2-t1

    K_lag = int(T_lag / chrono.dt) + 1  # Lag in indices
    a_lag = K_lag//chrono.dkObs + 1     # Lag in obs indices

    return T_lag, K_lag, a_lag


def comp_K_plot(K_lag, a_lag, plot_u):
    K_plot = 2*a_lag     # Sum of lags of {f,a} series.
    if plot_u:
        K_plot += K_lag  # Add lag of u series.
    return K_plot


def update_alpha(key, stats, lines, scatters=None):
    &#34;&#34;&#34;Adjust color alpha (for particle filters).&#34;&#34;&#34;
    k, kObs, faus = key
    if kObs is None:
        return
    if faus == &#39;f&#39;:
        return
    if not hasattr(stats, &#39;w&#39;):
        return

    # Compute alpha values
    w     = stats.w[key]
    alpha = (w/w.max()).clip(0.1, 0.4)

    # Set line alpha
    for line, a in zip(lines, alpha):
        line.set_alpha(a)

    # Scatter plot does not have alpha. =&gt; Fake it.
    if scatters is not None:
        colors = scatters.get_facecolor()[:, :3]
        if len(colors) == 1:
            colors = colors.repeat(len(w), axis=0)
        scatters.set_color(np.hstack([colors, alpha[:, None]]))


def duplicate_with_blanks_for_resampled(E, dims, key, has_w):
    &#34;&#34;&#34;Particle filter: insert breaks for resampled particles.&#34;&#34;&#34;
    if E is None:
        return [E]
    EE = []
    E  = E[:, dims]
    if has_w:
        k, kObs, faus = key
        if faus == &#39;f&#39;:
            pass
        elif faus == &#39;a&#39;:
            _Ea[0] = E[:, 0]  # Store (1st dim of) ens.
        elif faus == &#39;u&#39; and kObs is not None:
            # Find resampled particles. Insert duplicate ensemble. Write nans (breaks).
            resampled = _Ea[0] != E[:, 0]  # Mark as resampled if ens changed.
            # Insert current ensemble (copy to avoid overwriting).
            EE.append(E.copy())
            EE[0][resampled] = nan  # Write breaks
    # Always: append current ensemble
    EE.append(E)
    return EE


_Ea = [None]  # persistent storage for ens


def d_ylim(data, ax=None, cC=0, cE=1, pp=(1, 99), Min=-1e20, Max=+1e20):
    &#34;&#34;&#34;Provide new ylim&#39;s intelligently, from percentiles of the data.

    - `data`: iterable of arrays for computing percentiles.
    - `pp`: percentiles

    - `ax`: If present, then the delta_zoom in/out is also considered.

      - `cE`: exansion (widenting) rate âˆˆ [0,1].
        Default: 1, which immediately expands to percentile.
      - `cC`: compression (narrowing) rate âˆˆ [0,1].
        Default: 0, which does not allow compression.

    - `Min`/`Max`: bounds

    Despite being a little involved,
    the cost of this subroutine is typically not substantial
    because there&#39;s usually not that much data to sort through.
    &#34;&#34;&#34;
    # Find &#34;reasonable&#34; limits (by percentiles), looping over data
    maxv = minv = -np.inf  # init
    for d in data:
        d = d[np.isfinite(d)]
        if len(d):
            perc = np.array([-1, 1]) * np.percentile(d, pp)
            minv, maxv = np.maximum([minv, maxv], perc)
    minv *= -1

    # Pry apart equal values
    if np.isclose(minv, maxv):
        maxv += 0.5
        minv -= 0.5

    # Make the zooming transition smooth
    if ax is not None:
        current = ax.get_ylim()
        # Set rate factor as compress or expand factor.
        c0 = cC if minv &gt; current[0] else cE
        c1 = cC if maxv &lt; current[1] else cE
        # Adjust
        minv = np.interp(c0, (0, 1), (current[0], minv))
        maxv = np.interp(c1, (0, 1), (current[1], maxv))

    # Bounds
    maxv = min(Max, maxv)
    minv = max(Min, minv)

    # Set (if anything&#39;s changed)
    def worth_updating(a, b, curr):
        # Note: should depend on cC and cE
        d = abs(curr[1]-curr[0])
        lower = abs(a-curr[0]) &gt; 0.002*d
        upper = abs(b-curr[1]) &gt; 0.002*d
        return lower and upper
    # if worth_updating(minv,maxv,current):
        # ax.set_ylim(minv,maxv)

    # Some mpl versions don&#39;t handle inf limits.
    if not np.isfinite(minv):
        minv = None
    if not np.isfinite(maxv):
        maxv = None

    return minv, maxv


def spatial1d(
    obs_inds     = None,
    periodicity  = None,
    dims         = (),
    ens_props    = {&#39;color&#39;: &#39;k&#39;, &#39;alpha&#39;: 0.1},  # noqa
    conf_mult    = None,
):

    # Store parameters
    params_orig = DotDict(**locals())

    def init(fignum, stats, key0, plot_u, E, P, **kwargs):
        xx, yy, mu = stats.xx, stats.yy, stats.mu

        # Set parameters (kwargs takes precedence over params_orig)
        p = DotDict(**{
            kw: kwargs.get(kw, val) for kw, val in params_orig.items()})

        if not p.dims:
            M = xx.shape[-1]
            p.dims = arange(M)
        else:
            M = len(p.dims)

        # Make periodic wrapper
        ii, wrap = viz.setup_wrapping(M, p.periodicity)

        # Set up figure, axes
        fig, ax = place.freshfig(fignum, figsize=(8, 5))
        fig.suptitle(&#34;1d amplitude plot&#34;)

        # Nans
        nan1 = wrap(nan*ones(M))

        if E is None and p.conf_mult is None:
            p.conf_mult = 2

        # Init plots
        if p.conf_mult:
            lines_s  = ax.plot(ii, nan1, &#34;b-&#34;, lw=1,
                               label=(str(p.conf_mult) + r&#39;$\sigma$ conf&#39;))
            lines_s += ax.plot(ii, nan1, &#34;b-&#34;, lw=1)
            line_mu, = ax.plot(ii, nan1, &#39;b-&#39;, lw=2, label=&#39;DA mean&#39;)
        else:
            nanE     = nan*ones((stats.xp.N, M))
            lines_E  = ax.plot(ii, wrap(nanE[0]), **p.ens_props, lw=1, label=&#39;Ensemble&#39;)
            lines_E += ax.plot(ii, wrap(nanE[1:]).T, **p.ens_props, lw=1)
        # Truth, Obs
        (line_x, )   = ax.plot(ii, nan1, &#39;k-&#39;, lw=3, label=&#39;Truth&#39;)
        if p.obs_inds is not None:
            (line_y, ) = ax.plot(p.obs_inds, nan*p.obs_inds, &#39;g*&#39;, ms=5, label=&#39;Obs&#39;)

        # Tune plot
        ax.set_ylim(*viz.xtrema(xx))
        ax.set_xlim(viz.stretch(ii[0], ii[-1], 1))
        # Xticks
        xt = ax.get_xticks()
        xt = xt[abs(xt % 1) &lt; 0.01].astype(int)  # Keep only the integer ticks
        xt = xt[xt &gt;= 0]
        xt = xt[xt &lt; len(p.dims)]
        ax.set_xticks(xt)
        ax.set_xticklabels(p.dims[xt])

        ax.set_xlabel(&#39;State index&#39;)
        ax.set_ylabel(&#39;Value&#39;)
        ax.legend(loc=&#39;upper right&#39;)

        text_t = ax.text(0.01, 0.01, format_time(None, None, None),
                         transform=ax.transAxes, family=&#39;monospace&#39;, ha=&#39;left&#39;)

        # Init visibility (must come after legend):
        if p.obs_inds is not None:
            line_y.set_visible(False)

        def update(key, E, P):
            k, kObs, faus = key

            if p.conf_mult:
                sigma = mu[key] + p.conf_mult * stats.std[key] * [[1], [-1]]
                lines_s[0].set_ydata(wrap(sigma[0, p.dims]))
                lines_s[1].set_ydata(wrap(sigma[1, p.dims]))
                line_mu   .set_ydata(wrap(mu[key][p.dims]))
            else:
                for n, line in enumerate(lines_E):
                    line.set_ydata(wrap(E[n, p.dims]))
                update_alpha(key, stats, lines_E)

            line_x.set_ydata(wrap(xx[k, p.dims]))

            text_t.set_text(format_time(k, kObs, stats.HMM.t.tt[k]))

            if &#39;f&#39; in faus:
                if p.obs_inds is not None:
                    line_y.set_ydata(yy[kObs])
                    line_y.set_zorder(5)
                    line_y.set_visible(True)

            if &#39;u&#39; in faus:
                if p.obs_inds is not None:
                    line_y.set_visible(False)

            return
        return update
    return init


def spatial2d(
    square,
    ind2sub,
    obs_inds = None,
    cm       = plt.cm.jet,
    clims    = ((-40, 40), (-40, 40), (-10, 10), (-10, 10)),
):

    def init(fignum, stats, key0, plot_u, E, P, **kwargs):

        GS = {&#39;left&#39;: 0.125-0.04, &#39;right&#39;: 0.9-0.04}
        fig, axs = place.freshfig(fignum, figsize=(6, 6),
                                  nrows=2, ncols=2, sharex=True, sharey=True,
                                  gridspec_kw=GS)

        for ax in axs.flatten():
            ax.set_aspect(&#39;equal&#39;, &#39;box&#39;)

        ((ax_11, ax_12), (ax_21, ax_22)) = axs

        ax_11.grid(color=&#39;w&#39;, linewidth=0.2)
        ax_12.grid(color=&#39;w&#39;, linewidth=0.2)
        ax_21.grid(color=&#39;k&#39;, linewidth=0.1)
        ax_22.grid(color=&#39;k&#39;, linewidth=0.1)

        # Upper colorbar -- position relative to ax_12
        bb    = ax_12.get_position()
        dy    = 0.1*bb.height
        ax_13 = fig.add_axes([bb.x1+0.03, bb.y0 + dy, 0.04, bb.height - 2*dy])
        # Lower colorbar -- position relative to ax_22
        bb    = ax_22.get_position()
        dy    = 0.1*bb.height
        ax_23 = fig.add_axes([bb.x1+0.03, bb.y0 + dy, 0.04, bb.height - 2*dy])

        # Extract data arrays
        xx, _, mu, std, err = stats.xx, stats.yy, stats.mu, stats.std, stats.err
        k = key0[0]
        tt = stats.HMM.t.tt

        # Plot
        # - origin=&#39;lower&#39; might get overturned by set_ylim() below.
        im_11 = ax_11.imshow(square(mu[key0]), cmap=cm)
        im_12 = ax_12.imshow(square(xx[k]), cmap=cm)
        # hot is better, but needs +1 colorbar
        im_21 = ax_21.imshow(square(std[key0]), cmap=plt.cm.bwr)
        im_22 = ax_22.imshow(square(err[key0]), cmap=plt.cm.bwr)
        ims = (im_11, im_12, im_21, im_22)
        # Obs init -- a list where item 0 is the handle of something invisible.
        lh = list(ax_12.plot(0, 0)[0:1])

        sx = &#39;$\\psi$&#39;
        ax_11.set_title(&#39;mean &#39;+sx)
        ax_12.set_title(&#39;true &#39;+sx)
        ax_21.set_title(&#39;std. &#39;+sx)
        ax_22.set_title(&#39;err. &#39;+sx)

        # TODO 7
        # for ax in axs.flatten():
        # Crop boundries (which should be 0, i.e. yield harsh q gradients):
        # lims = (1, nx-2)
        # step = (nx - 1)/8
        # ticks = arange(step,nx-1,step)
        # ax.set_xlim  (lims)
        # ax.set_ylim  (lims[::-1])
        # ax.set_xticks(ticks)
        # ax.set_yticks(ticks)

        for im, clim in zip(ims, clims):
            im.set_clim(clim)

        fig.colorbar(im_12, cax=ax_13)
        fig.colorbar(im_22, cax=ax_23)
        for ax in [ax_13, ax_23]:
            ax.yaxis.set_tick_params(&#39;major&#39;, length=2, width=0.5,
                                     direction=&#39;in&#39;, left=True, right=True)
            ax.set_axisbelow(&#39;line&#39;)  # make ticks appear over colorbar patch

        # Title
        title = &#34;Streamfunction (&#34;+sx+&#34;)&#34;
        fig.suptitle(title)
        # Time info
        text_t = ax_12.text(1, 1.1, format_time(None, None, None),
                            transform=ax_12.transAxes, family=&#39;monospace&#39;, ha=&#39;left&#39;)

        def update(key, E, P):
            k, kObs, faus = key
            t = tt[k]

            im_11.set_data(square(mu[key]))
            im_12.set_data(square(xx[k]))
            im_21.set_data(square(std[key]))
            im_22.set_data(square(err[key]))

            # Remove previous obs
            try:
                lh[0].remove()
            except ValueError:
                pass
            # Plot current obs.
            #  - plot() automatically adjusts to direction of y-axis in use.
            #  - ind2sub returns (iy,ix), while plot takes (ix,iy) =&gt; reverse.
            if kObs is not None and obs_inds is not None:
                lh[0] = ax_12.plot(*ind2sub(obs_inds(t))[::-1], &#39;k.&#39;, ms=1, zorder=5)[0]

            text_t.set_text(format_time(k, kObs, t))

            return
        return update
    return init


# List of liveplotters available for all HMMs.
# Columns:
# - fignum
# - show_by_default
# - function/class
default_liveplotters = [
    (1, sliding_diagnostics),
    (1, weight_histogram),
]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dapper.tools.liveplotting.sliding_xlim"><code class="name flex">
<span>def <span class="ident">sliding_xlim</span></span>(<span>ax, tt, lag, margin=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L451-L470" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sliding_xlim(ax, tt, lag, margin=False):
    dt = lag/20 if margin else 0
    if tt.nFilled == 0:
        return  # Quit
    t1, t2 = tt.span()      # Get suggested span.
    s1, s2 = ax.get_xlim()  # Get previous lims.
    # If zero span (eg tt holds single &#39;f&#39; and &#39;a&#39;):
    if t1 == t2:
        t1 -= 1  # add width
        t2 += 1  # add width
    # If user has skipped (too much):
    elif np.isnan(t1):
        s2    -= dt     # Correct for dt.
        span   = s2-s1  # Compute previous span
        # If span&lt;lag:
        if span &lt; lag:
            span  += (t2-s2)  # Grow by &#34;dt&#34;.
        span   = min(lag, span)  # Bound
        t1     = t2 - span       # Set span.
    ax.set_xlim(t1, t2 + dt)  # Set xlim to span</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.circulant_ACF"><code class="name flex">
<span>def <span class="ident">circulant_ACF</span></span>(<span>C, do_abs=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the auto-covariance-function corresponding to <code>C</code>.</p>
<p>This assumes it is the cov/corr matrix of a 1D periodic domain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L661-L676" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def circulant_ACF(C, do_abs=False):
    &#34;&#34;&#34;Compute the auto-covariance-function corresponding to `C`.

    This assumes it is the cov/corr matrix of a 1D periodic domain.
    &#34;&#34;&#34;
    M = len(C)
    # cols = np.flipud(sla.circulant(np.arange(M)[::-1]))
    cols = sla.circulant(np.arange(M))
    ACF = np.zeros(M)
    for i in range(M):
        row = C[i, cols[i]]
        if do_abs:
            row = abs(row)
        ACF += row
        # Note: this actually also accesses masked values in C.
    return ACF/M</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.sliding_marginals"><code class="name flex">
<span>def <span class="ident">sliding_marginals</span></span>(<span>obs_inds=(), dims=(), labels=(), Tplot=None, ens_props={'alpha': 0.4}, zoomy=1.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L679-L829" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sliding_marginals(
    obs_inds     = (),
    dims         = (),
    labels       = (),
    Tplot        = None,
    ens_props    = dict(alpha=0.4),  # noqa
    zoomy        = 1.0,
):

    # Store parameters
    params_orig = DotDict(**locals())

    def init(fignum, stats, key0, plot_u, E, P, **kwargs):
        xx, yy, mu, std, chrono = \
            stats.xx, stats.yy, stats.mu, stats.std, stats.HMM.t

        # Set parameters (kwargs takes precedence over params_orig)
        p = DotDict(**{
            kw: kwargs.get(kw, val) for kw, val in params_orig.items()})

        # Lag settings:
        T_lag, K_lag, a_lag = validate_lag(p.Tplot, chrono)
        K_plot = comp_K_plot(K_lag, a_lag, plot_u)
        # Extend K_plot forther for adding blanks in resampling (PartFilt):
        has_w = hasattr(stats, &#39;w&#39;)
        if has_w:
            K_plot += a_lag

        # Chose marginal dims to plot
        if not p.dims:
            Nx      = min(10, xx.shape[-1])
            DimsX   = linspace_int(xx.shape[-1], Nx)
        else:
            Nx      = len(p.dims)
            DimsX   = p.dims
        # Pre-process obs dimensions
        # Rm inds of obs if not in DimsX
        iiY   = [i for i, m in enumerate(p.obs_inds) if m in DimsX]
        # Rm obs_inds    if not in DimsX
        DimsY = [m for i, m in enumerate(p.obs_inds) if m in DimsX]
        # Get dim (within y) of each x
        DimsY = [DimsY.index(m) if m in DimsY else None for m in DimsX]
        Ny    = len(iiY)

        # Set up figure, axes
        fig, axs = place.freshfig(fignum, figsize=(5, 7), nrows=Nx, sharex=True)
        if Nx == 1:
            axs = [axs]

        # Tune plots
        axs[0].set_title(&#34;Marginal time series&#34;)
        for ix, (m, ax) in enumerate(zip(DimsX, axs)):
            # ax.set_ylim(*viz.stretch(*viz.xtrema(xx[:, m]), 1/p.zoomy))
            if not p.labels:
                ax.set_ylabel(&#34;$x_{%d}$&#34; % m)
            else:
                ax.set_ylabel(p.labels[ix])
        axs[-1].set_xlabel(&#39;Time (t)&#39;)

        plot_pause(0.05)
        plt.tight_layout()

        # Allocate
        d = DotDict()  # data arrays
        h = DotDict()  # plot handles
        # Why &#34;if True&#34; ? Just to indent the rest of the line...
        if True:
            d.t  = RollingArray((K_plot,))
        if True:
            d.x  = RollingArray((K_plot, Nx))
            h.x  = []
        if True:
            d.y  = RollingArray((K_plot, Ny))
            h.y  = []
        if E is not None:
            d.E  = RollingArray((K_plot, len(E), Nx))
            h.E  = []
        if P is not None:
            d.mu = RollingArray((K_plot, Nx))
            h.mu = []
        if P is not None:
            d.s  = RollingArray((K_plot, 2, Nx))
            h.s  = []

        # Plot (invisible coz everything here is nan, for the moment).
        for ix, (_m, iy, ax) in enumerate(zip(DimsX, DimsY, axs)):
            if True:
                h.x  += ax.plot(d.t, d.x[:, ix], &#39;k&#39;)
            if iy != None:
                h.y  += ax.plot(d.t, d.y[:, iy], &#39;g*&#39;, ms=10)
            if &#39;E&#39; in d:
                h.E  += [ax.plot(d.t, d.E[:, :, ix], **p.ens_props)]
            if &#39;mu&#39; in d:
                h.mu += ax.plot(d.t, d.mu[:, ix], &#39;b&#39;)
            if &#39;s&#39; in d:
                h.s  += [ax.plot(d.t, d.s[:, :, ix], &#39;b--&#39;, lw=1)]

        def update(key, E, P):
            k, kObs, faus = key

            EE = duplicate_with_blanks_for_resampled(E, DimsX, key, has_w)

            # Roll data array
            ind = k if plot_u else kObs
            for Ens in EE:  # If E is duplicated, so must the others be.
                if &#39;E&#39; in d:
                    d.E .insert(ind, Ens)
                if &#39;mu&#39; in d:
                    d.mu.insert(ind, mu[key][DimsX])
                if &#39;s&#39; in d:
                    d.s .insert(ind, mu[key][DimsX] + [[1], [-1]]*std[key][DimsX])
                if True:
                    d.t .insert(ind, chrono.tt[k])
                if True:
                    d.y .insert(ind, yy[kObs, iiY]
                                if kObs is not None else nan*ones(Ny))
                if True:
                    d.x .insert(ind, xx[k, DimsX])

            # Update graphs
            for ix, (_m, iy, ax) in enumerate(zip(DimsX, DimsY, axs)):
                sliding_xlim(ax, d.t, T_lag, True)
                if True:
                    h.x[ix]    .set_data(d.t, d.x[:, ix])
                if iy != None:
                    h.y[iy]    .set_data(d.t, d.y[:, iy])
                if &#39;mu&#39; in d:
                    h.mu[ix]   .set_data(d.t, d.mu[:, ix])
                if &#39;s&#39; in d:
                    [h.s[ix][b].set_data(d.t, d.s[:, b, ix]) for b in [0, 1]]
                if &#39;E&#39; in d:
                    [h.E[ix][n].set_data(d.t, d.E[:, n, ix]) for n in range(len(E))]
                if &#39;E&#39; in d:
                    update_alpha(key, stats, h.E[ix])

                # TODO 3: fixup. This might be slow?
                # In any case, it is very far from tested.
                # Also, relim&#39;iting all of the time is distracting.
                # Use d_ylim?
                if &#39;E&#39; in d:
                    lims = d.E
                elif &#39;mu&#39; in d:
                    lims = d.mu
                lims = np.array(viz.xtrema(lims[..., ix]))
                if lims[0] == lims[1]:
                    lims += [-.5, +.5]
                ax.set_ylim(*viz.stretch(*lims, 1/p.zoomy))

            return
        return update
    return init</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.phase_particles"><code class="name flex">
<span>def <span class="ident">phase_particles</span></span>(<span>is_3d=True, obs_inds=(), dims=(), labels=(), Tplot=None, ens_props={'alpha': 0.4}, zoom=1.5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L832-L965" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def phase_particles(
    is_3d        = True,
    obs_inds     = (),
    dims         = (),
    labels       = (),
    Tplot        = None,
    ens_props    = dict(alpha=0.4),  # noqa
    zoom         = 1.5,
):

    # Store parameters
    params_orig = DotDict(**locals())

    M = 3 if is_3d else 2

    def init(fignum, stats, key0, plot_u, E, P, **kwargs):
        xx, yy, mu, _, chrono = \
            stats.xx, stats.yy, stats.mu, stats.std, stats.HMM.t

        # Set parameters (kwargs takes precedence over params_orig)
        p = DotDict(**{
            kw: kwargs.get(kw, val) for kw, val in params_orig.items()})

        # Lag settings:
        has_w = hasattr(stats, &#39;w&#39;)
        if p.Tplot == 0:
            K_plot = 1
        else:
            T_lag, K_lag, a_lag = validate_lag(p.Tplot, chrono)
            K_plot = comp_K_plot(K_lag, a_lag, plot_u)
            # Extend K_plot forther for adding blanks in resampling (PartFilt):
            if has_w:
                K_plot += a_lag

        # Dimension settings
        if not p.dims:
            p.dims   = arange(M)
        if not p.labels:
            p.labels = [&#34;$x_%d$&#34; % d for d in p.dims]
        assert len(p.dims) == M

        # Set up figure, axes
        fig, _ = place.freshfig(fignum, figsize=(5, 5))
        ax = plt.subplot(111, projection=&#39;3d&#39; if is_3d else None)
        ax.set_facecolor(&#39;w&#39;)
        ax.set_title(&#34;Phase space trajectories&#34;)
        # Tune plot
        for ind, (s, i, t) in enumerate(zip(p.labels, p.dims, &#34;xyz&#34;)):
            viz.set_ilim(ax, ind, *viz.stretch(*viz.xtrema(xx[:, i]), 1/p.zoom))
            eval(&#34;ax.set_%slabel(&#39;%s&#39;)&#34; % (t, s))

        # Allocate
        d = DotDict()  # data arrays
        h = DotDict()  # plot handles
        s = DotDict()  # scatter handles
        if E is not None:
            d.E  = RollingArray((K_plot, len(E), M))
            h.E = []
        if P is not None:
            d.mu = RollingArray((K_plot, M))
        if True:
            d.x  = RollingArray((K_plot, M))
        if list(p.obs_inds) == list(p.dims):
            d.y  = RollingArray((K_plot, M))

        # Plot tails (invisible coz everything here is nan, for the moment).
        if &#39;E&#39; in d:
            h.E  += [ax.plot(*xn, **p.ens_props)[0]
                     for xn in np.transpose(d.E, [1, 2, 0])]
        if &#39;mu&#39; in d:
            h.mu  = ax.plot(*d.mu.T, &#39;b&#39;, lw=2)[0]
        if True:
            h.x   = ax.plot(*d.x .T, &#39;k&#39;, lw=3)[0]
        if &#39;y&#39; in d:
            h.y   = ax.plot(*d.y .T, &#39;g*&#39;, ms=14)[0]

        # Scatter. NB: don&#39;t init with nan&#39;s coz it&#39;s buggy
        # (wrt. get_color() and _offsets3d) since mpl 3.1.
        if &#39;E&#39; in d:
            s.E   = ax.scatter(*E.T[p.dims], s=3**2,
                               c=[hn.get_color() for hn in h.E])
        if &#39;mu&#39; in d:
            s.mu  = ax.scatter(*ones(M), s=8**2,
                               c=[h.mu.get_color()])
        if True:
            s.x  = ax.scatter(*ones(M), s=14**2,
                              c=[h.x.get_color()], marker=(5, 1), zorder=99)

        def update(key, E, P):
            k, kObs, faus = key
            show_y = &#39;y&#39; in d and kObs is not None

            def update_tail(handle, newdata):
                handle.set_data(newdata[:, 0], newdata[:, 1])
                if is_3d:
                    handle.set_3d_properties(newdata[:, 2])

            def update_sctr(handle, newdata):
                if is_3d:
                    handle._offsets3d = juggle_axes(*newdata.T, &#39;z&#39;)
                else:
                    handle.set_offsets(newdata)

            EE = duplicate_with_blanks_for_resampled(E, p.dims, key, has_w)

            # Roll data array
            ind = k if plot_u else kObs
            for Ens in EE:  # If E is duplicated, so must the others be.
                if &#39;E&#39; in d:
                    d.E .insert(ind, Ens)
                if True:
                    d.x .insert(ind, xx[k, p.dims])
                if &#39;y&#39; in d:
                    d.y .insert(ind, yy[kObs, :] if show_y else nan*ones(M))
                if &#39;mu&#39; in d:
                    d.mu.insert(ind, mu[key][p.dims])

            # Update graph
            update_sctr(s.x, d.x[[-1]])
            update_tail(h.x, d.x)
            if &#39;y&#39; in d:
                update_tail(h.y, d.y)
            if &#39;mu&#39; in d:
                update_sctr(s.mu, d.mu[[-1]])
                update_tail(h.mu, d.mu)
            else:
                update_sctr(s.E, d.E[-1])
                for n in range(len(E)):
                    update_tail(h.E[n], d.E[:, n, :])
                update_alpha(key, stats, h.E, s.E)

            return
        return update
    return init</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.validate_lag"><code class="name flex">
<span>def <span class="ident">validate_lag</span></span>(<span>Tplot, chrono)</span>
</code></dt>
<dd>
<div class="desc"><p>Return validated <code>T_lag</code> such that is is:</p>
<ul>
<li>equal to <code>Tplot</code> with fallback: <code>HMM.t.Tplot</code>.</li>
<li>no longer than <code>HMM.t.T</code>.</li>
</ul>
<p>Also return corresponding <code>K_lag</code>, <code>a_lag</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L968-L993" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def validate_lag(Tplot, chrono):
    &#34;&#34;&#34;Return validated `T_lag` such that is is:

    - equal to `Tplot` with fallback: `HMM.t.Tplot`.
    - no longer than `HMM.t.T`.

    Also return corresponding `K_lag`, `a_lag`.
    &#34;&#34;&#34;
    # Defaults
    if Tplot is None:
        Tplot = chrono.Tplot

    # Rename
    T_lag = Tplot

    assert T_lag &gt;= 0

    # Validate T_lag
    t2 = chrono.tt[-1]
    t1 = max(chrono.tt[0], t2-T_lag)
    T_lag = t2-t1

    K_lag = int(T_lag / chrono.dt) + 1  # Lag in indices
    a_lag = K_lag//chrono.dkObs + 1     # Lag in obs indices

    return T_lag, K_lag, a_lag</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.comp_K_plot"><code class="name flex">
<span>def <span class="ident">comp_K_plot</span></span>(<span>K_lag, a_lag, plot_u)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L996-L1000" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def comp_K_plot(K_lag, a_lag, plot_u):
    K_plot = 2*a_lag     # Sum of lags of {f,a} series.
    if plot_u:
        K_plot += K_lag  # Add lag of u series.
    return K_plot</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.update_alpha"><code class="name flex">
<span>def <span class="ident">update_alpha</span></span>(<span>key, stats, lines, scatters=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjust color alpha (for particle filters).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L1003-L1026" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update_alpha(key, stats, lines, scatters=None):
    &#34;&#34;&#34;Adjust color alpha (for particle filters).&#34;&#34;&#34;
    k, kObs, faus = key
    if kObs is None:
        return
    if faus == &#39;f&#39;:
        return
    if not hasattr(stats, &#39;w&#39;):
        return

    # Compute alpha values
    w     = stats.w[key]
    alpha = (w/w.max()).clip(0.1, 0.4)

    # Set line alpha
    for line, a in zip(lines, alpha):
        line.set_alpha(a)

    # Scatter plot does not have alpha. =&gt; Fake it.
    if scatters is not None:
        colors = scatters.get_facecolor()[:, :3]
        if len(colors) == 1:
            colors = colors.repeat(len(w), axis=0)
        scatters.set_color(np.hstack([colors, alpha[:, None]]))</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.duplicate_with_blanks_for_resampled"><code class="name flex">
<span>def <span class="ident">duplicate_with_blanks_for_resampled</span></span>(<span>E, dims, key, has_w)</span>
</code></dt>
<dd>
<div class="desc"><p>Particle filter: insert breaks for resampled particles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L1029-L1049" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def duplicate_with_blanks_for_resampled(E, dims, key, has_w):
    &#34;&#34;&#34;Particle filter: insert breaks for resampled particles.&#34;&#34;&#34;
    if E is None:
        return [E]
    EE = []
    E  = E[:, dims]
    if has_w:
        k, kObs, faus = key
        if faus == &#39;f&#39;:
            pass
        elif faus == &#39;a&#39;:
            _Ea[0] = E[:, 0]  # Store (1st dim of) ens.
        elif faus == &#39;u&#39; and kObs is not None:
            # Find resampled particles. Insert duplicate ensemble. Write nans (breaks).
            resampled = _Ea[0] != E[:, 0]  # Mark as resampled if ens changed.
            # Insert current ensemble (copy to avoid overwriting).
            EE.append(E.copy())
            EE[0][resampled] = nan  # Write breaks
    # Always: append current ensemble
    EE.append(E)
    return EE</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.d_ylim"><code class="name flex">
<span>def <span class="ident">d_ylim</span></span>(<span>data, ax=None, cC=0, cE=1, pp=(1, 99), Min=-1e+20, Max=1e+20)</span>
</code></dt>
<dd>
<div class="desc"><p>Provide new ylim's intelligently, from percentiles of the data.</p>
<ul>
<li><code>data</code>: iterable of arrays for computing percentiles.</li>
<li>
<p><code>pp</code>: percentiles</p>
</li>
<li>
<p><code>ax</code>: If present, then the delta_zoom in/out is also considered.</p>
</li>
<li>
<p><code>cE</code>: exansion (widenting) rate âˆˆ [0,1].
Default: 1, which immediately expands to percentile.</p>
</li>
<li>
<p><code>cC</code>: compression (narrowing) rate âˆˆ [0,1].
Default: 0, which does not allow compression.</p>
</li>
<li>
<p><code>Min</code>/<code>Max</code>: bounds</p>
</li>
</ul>
<p>Despite being a little involved,
the cost of this subroutine is typically not substantial
because there's usually not that much data to sort through.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L1055-L1118" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def d_ylim(data, ax=None, cC=0, cE=1, pp=(1, 99), Min=-1e20, Max=+1e20):
    &#34;&#34;&#34;Provide new ylim&#39;s intelligently, from percentiles of the data.

    - `data`: iterable of arrays for computing percentiles.
    - `pp`: percentiles

    - `ax`: If present, then the delta_zoom in/out is also considered.

      - `cE`: exansion (widenting) rate âˆˆ [0,1].
        Default: 1, which immediately expands to percentile.
      - `cC`: compression (narrowing) rate âˆˆ [0,1].
        Default: 0, which does not allow compression.

    - `Min`/`Max`: bounds

    Despite being a little involved,
    the cost of this subroutine is typically not substantial
    because there&#39;s usually not that much data to sort through.
    &#34;&#34;&#34;
    # Find &#34;reasonable&#34; limits (by percentiles), looping over data
    maxv = minv = -np.inf  # init
    for d in data:
        d = d[np.isfinite(d)]
        if len(d):
            perc = np.array([-1, 1]) * np.percentile(d, pp)
            minv, maxv = np.maximum([minv, maxv], perc)
    minv *= -1

    # Pry apart equal values
    if np.isclose(minv, maxv):
        maxv += 0.5
        minv -= 0.5

    # Make the zooming transition smooth
    if ax is not None:
        current = ax.get_ylim()
        # Set rate factor as compress or expand factor.
        c0 = cC if minv &gt; current[0] else cE
        c1 = cC if maxv &lt; current[1] else cE
        # Adjust
        minv = np.interp(c0, (0, 1), (current[0], minv))
        maxv = np.interp(c1, (0, 1), (current[1], maxv))

    # Bounds
    maxv = min(Max, maxv)
    minv = max(Min, minv)

    # Set (if anything&#39;s changed)
    def worth_updating(a, b, curr):
        # Note: should depend on cC and cE
        d = abs(curr[1]-curr[0])
        lower = abs(a-curr[0]) &gt; 0.002*d
        upper = abs(b-curr[1]) &gt; 0.002*d
        return lower and upper
    # if worth_updating(minv,maxv,current):
        # ax.set_ylim(minv,maxv)

    # Some mpl versions don&#39;t handle inf limits.
    if not np.isfinite(minv):
        minv = None
    if not np.isfinite(maxv):
        maxv = None

    return minv, maxv</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.spatial1d"><code class="name flex">
<span>def <span class="ident">spatial1d</span></span>(<span>obs_inds=None, periodicity=None, dims=(), ens_props={'color': 'k', 'alpha': 0.1}, conf_mult=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L1121-L1224" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def spatial1d(
    obs_inds     = None,
    periodicity  = None,
    dims         = (),
    ens_props    = {&#39;color&#39;: &#39;k&#39;, &#39;alpha&#39;: 0.1},  # noqa
    conf_mult    = None,
):

    # Store parameters
    params_orig = DotDict(**locals())

    def init(fignum, stats, key0, plot_u, E, P, **kwargs):
        xx, yy, mu = stats.xx, stats.yy, stats.mu

        # Set parameters (kwargs takes precedence over params_orig)
        p = DotDict(**{
            kw: kwargs.get(kw, val) for kw, val in params_orig.items()})

        if not p.dims:
            M = xx.shape[-1]
            p.dims = arange(M)
        else:
            M = len(p.dims)

        # Make periodic wrapper
        ii, wrap = viz.setup_wrapping(M, p.periodicity)

        # Set up figure, axes
        fig, ax = place.freshfig(fignum, figsize=(8, 5))
        fig.suptitle(&#34;1d amplitude plot&#34;)

        # Nans
        nan1 = wrap(nan*ones(M))

        if E is None and p.conf_mult is None:
            p.conf_mult = 2

        # Init plots
        if p.conf_mult:
            lines_s  = ax.plot(ii, nan1, &#34;b-&#34;, lw=1,
                               label=(str(p.conf_mult) + r&#39;$\sigma$ conf&#39;))
            lines_s += ax.plot(ii, nan1, &#34;b-&#34;, lw=1)
            line_mu, = ax.plot(ii, nan1, &#39;b-&#39;, lw=2, label=&#39;DA mean&#39;)
        else:
            nanE     = nan*ones((stats.xp.N, M))
            lines_E  = ax.plot(ii, wrap(nanE[0]), **p.ens_props, lw=1, label=&#39;Ensemble&#39;)
            lines_E += ax.plot(ii, wrap(nanE[1:]).T, **p.ens_props, lw=1)
        # Truth, Obs
        (line_x, )   = ax.plot(ii, nan1, &#39;k-&#39;, lw=3, label=&#39;Truth&#39;)
        if p.obs_inds is not None:
            (line_y, ) = ax.plot(p.obs_inds, nan*p.obs_inds, &#39;g*&#39;, ms=5, label=&#39;Obs&#39;)

        # Tune plot
        ax.set_ylim(*viz.xtrema(xx))
        ax.set_xlim(viz.stretch(ii[0], ii[-1], 1))
        # Xticks
        xt = ax.get_xticks()
        xt = xt[abs(xt % 1) &lt; 0.01].astype(int)  # Keep only the integer ticks
        xt = xt[xt &gt;= 0]
        xt = xt[xt &lt; len(p.dims)]
        ax.set_xticks(xt)
        ax.set_xticklabels(p.dims[xt])

        ax.set_xlabel(&#39;State index&#39;)
        ax.set_ylabel(&#39;Value&#39;)
        ax.legend(loc=&#39;upper right&#39;)

        text_t = ax.text(0.01, 0.01, format_time(None, None, None),
                         transform=ax.transAxes, family=&#39;monospace&#39;, ha=&#39;left&#39;)

        # Init visibility (must come after legend):
        if p.obs_inds is not None:
            line_y.set_visible(False)

        def update(key, E, P):
            k, kObs, faus = key

            if p.conf_mult:
                sigma = mu[key] + p.conf_mult * stats.std[key] * [[1], [-1]]
                lines_s[0].set_ydata(wrap(sigma[0, p.dims]))
                lines_s[1].set_ydata(wrap(sigma[1, p.dims]))
                line_mu   .set_ydata(wrap(mu[key][p.dims]))
            else:
                for n, line in enumerate(lines_E):
                    line.set_ydata(wrap(E[n, p.dims]))
                update_alpha(key, stats, lines_E)

            line_x.set_ydata(wrap(xx[k, p.dims]))

            text_t.set_text(format_time(k, kObs, stats.HMM.t.tt[k]))

            if &#39;f&#39; in faus:
                if p.obs_inds is not None:
                    line_y.set_ydata(yy[kObs])
                    line_y.set_zorder(5)
                    line_y.set_visible(True)

            if &#39;u&#39; in faus:
                if p.obs_inds is not None:
                    line_y.set_visible(False)

            return
        return update
    return init</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.spatial2d"><code class="name flex">
<span>def <span class="ident">spatial2d</span></span>(<span>square, ind2sub, obs_inds=None, cm=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;, clims=((-40, 40), (-40, 40), (-10, 10), (-10, 10)))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L1227-L1335" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def spatial2d(
    square,
    ind2sub,
    obs_inds = None,
    cm       = plt.cm.jet,
    clims    = ((-40, 40), (-40, 40), (-10, 10), (-10, 10)),
):

    def init(fignum, stats, key0, plot_u, E, P, **kwargs):

        GS = {&#39;left&#39;: 0.125-0.04, &#39;right&#39;: 0.9-0.04}
        fig, axs = place.freshfig(fignum, figsize=(6, 6),
                                  nrows=2, ncols=2, sharex=True, sharey=True,
                                  gridspec_kw=GS)

        for ax in axs.flatten():
            ax.set_aspect(&#39;equal&#39;, &#39;box&#39;)

        ((ax_11, ax_12), (ax_21, ax_22)) = axs

        ax_11.grid(color=&#39;w&#39;, linewidth=0.2)
        ax_12.grid(color=&#39;w&#39;, linewidth=0.2)
        ax_21.grid(color=&#39;k&#39;, linewidth=0.1)
        ax_22.grid(color=&#39;k&#39;, linewidth=0.1)

        # Upper colorbar -- position relative to ax_12
        bb    = ax_12.get_position()
        dy    = 0.1*bb.height
        ax_13 = fig.add_axes([bb.x1+0.03, bb.y0 + dy, 0.04, bb.height - 2*dy])
        # Lower colorbar -- position relative to ax_22
        bb    = ax_22.get_position()
        dy    = 0.1*bb.height
        ax_23 = fig.add_axes([bb.x1+0.03, bb.y0 + dy, 0.04, bb.height - 2*dy])

        # Extract data arrays
        xx, _, mu, std, err = stats.xx, stats.yy, stats.mu, stats.std, stats.err
        k = key0[0]
        tt = stats.HMM.t.tt

        # Plot
        # - origin=&#39;lower&#39; might get overturned by set_ylim() below.
        im_11 = ax_11.imshow(square(mu[key0]), cmap=cm)
        im_12 = ax_12.imshow(square(xx[k]), cmap=cm)
        # hot is better, but needs +1 colorbar
        im_21 = ax_21.imshow(square(std[key0]), cmap=plt.cm.bwr)
        im_22 = ax_22.imshow(square(err[key0]), cmap=plt.cm.bwr)
        ims = (im_11, im_12, im_21, im_22)
        # Obs init -- a list where item 0 is the handle of something invisible.
        lh = list(ax_12.plot(0, 0)[0:1])

        sx = &#39;$\\psi$&#39;
        ax_11.set_title(&#39;mean &#39;+sx)
        ax_12.set_title(&#39;true &#39;+sx)
        ax_21.set_title(&#39;std. &#39;+sx)
        ax_22.set_title(&#39;err. &#39;+sx)

        # TODO 7
        # for ax in axs.flatten():
        # Crop boundries (which should be 0, i.e. yield harsh q gradients):
        # lims = (1, nx-2)
        # step = (nx - 1)/8
        # ticks = arange(step,nx-1,step)
        # ax.set_xlim  (lims)
        # ax.set_ylim  (lims[::-1])
        # ax.set_xticks(ticks)
        # ax.set_yticks(ticks)

        for im, clim in zip(ims, clims):
            im.set_clim(clim)

        fig.colorbar(im_12, cax=ax_13)
        fig.colorbar(im_22, cax=ax_23)
        for ax in [ax_13, ax_23]:
            ax.yaxis.set_tick_params(&#39;major&#39;, length=2, width=0.5,
                                     direction=&#39;in&#39;, left=True, right=True)
            ax.set_axisbelow(&#39;line&#39;)  # make ticks appear over colorbar patch

        # Title
        title = &#34;Streamfunction (&#34;+sx+&#34;)&#34;
        fig.suptitle(title)
        # Time info
        text_t = ax_12.text(1, 1.1, format_time(None, None, None),
                            transform=ax_12.transAxes, family=&#39;monospace&#39;, ha=&#39;left&#39;)

        def update(key, E, P):
            k, kObs, faus = key
            t = tt[k]

            im_11.set_data(square(mu[key]))
            im_12.set_data(square(xx[k]))
            im_21.set_data(square(std[key]))
            im_22.set_data(square(err[key]))

            # Remove previous obs
            try:
                lh[0].remove()
            except ValueError:
                pass
            # Plot current obs.
            #  - plot() automatically adjusts to direction of y-axis in use.
            #  - ind2sub returns (iy,ix), while plot takes (ix,iy) =&gt; reverse.
            if kObs is not None and obs_inds is not None:
                lh[0] = ax_12.plot(*ind2sub(obs_inds(t))[::-1], &#39;k.&#39;, ms=1, zorder=5)[0]

            text_t.set_text(format_time(k, kObs, t))

            return
        return update
    return init</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dapper.tools.liveplotting.LivePlot"><code class="flex name class">
<span>class <span class="ident">LivePlot</span></span>
<span>(</span><span>stats, liveplots, key0=(0, None, 'u'), E=None, P=None, speed=1.0, replay=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Live plotting manager.</p>
<p>Deals with</p>
<ul>
<li>Pause, skip.</li>
<li>Which liveploters to call.</li>
<li><code>plot_u</code></li>
<li>Figure window (title and number).</li>
</ul>
<p>Initialize plots.</p>
<ul>
<li>liveplots: figures to plot; alternatives:<ul>
<li><code>"default"/[]/True</code>: All default figures for this HMM.</li>
<li><code>"all"</code>
: Even more.</li>
<li>non-empty <code>list</code>
: Only the figures with these numbers
(int) or names (str).</li>
<li><code>False</code>
: None.</li>
</ul>
</li>
<li>speed: speed of animation.<ul>
<li><code>&gt;100</code>: instantaneous</li>
<li><code>1</code>
: (default) as quick as possible allowing for
plt.draw() to work on a moderately fast computer.</li>
<li><code>&lt;1</code>
: slower.</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L45-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LivePlot:
    &#34;&#34;&#34;Live plotting manager.

    Deals with

    - Pause, skip.
    - Which liveploters to call.
    - `plot_u`
    - Figure window (title and number).
    &#34;&#34;&#34;

    def __init__(self,
                 stats,
                 liveplots,
                 key0=(0, None, &#39;u&#39;),
                 E=None,
                 P=None,
                 speed=1.0,
                 replay=False,
                 **kwargs):
        &#34;&#34;&#34;
        Initialize plots.

        - liveplots: figures to plot; alternatives:
            - `&#34;default&#34;/[]/True`: All default figures for this HMM.
            - `&#34;all&#34;`            : Even more.
            - non-empty `list`   : Only the figures with these numbers
                                 (int) or names (str).
            - `False`            : None.
        - speed: speed of animation.
            - `&gt;100`: instantaneous
            - `1`   : (default) as quick as possible allowing for
                      plt.draw() to work on a moderately fast computer.
            - `&lt;1`  : slower.
        &#34;&#34;&#34;
        # Disable if not rc.liveplotting
        self.any_figs = False
        if not rc.liveplotting:
            return

        # Determine whether all/universal/intermediate stats are plotted
        self.plot_u = not replay or stats.store_u

        # Set speed/pause params
        self.params = {
            &#39;pause_f&#39;: 0.05,
            &#39;pause_a&#39;: 0.05,
            &#39;pause_s&#39;: 0.05,
            &#39;pause_u&#39;: 0.001,
        }
        # If speed&gt;100: set to inf. Coz pause=1e-99 causes hangup.
        for pause in [&#34;pause_&#34;+x for x in &#34;faus&#34;]:
            speed = speed if speed &lt; 100 else np.inf
            self.params[pause] /= speed

        # Write params
        self.params.update(getattr(stats.xp, &#34;LP_kwargs&#34;, {}))
        self.params.update(kwargs)

        def get_name(init):
            &#34;&#34;&#34;Get name of liveplotter function/class.&#34;&#34;&#34;
            try:
                return init.__qualname__.split(&#34;.&#34;)[0]
            except AttributeError:
                return init.__class__.__name__

        # Set up dict of liveplotters
        potential_LPs = {}
        for show, init in default_liveplotters:
            potential_LPs[get_name(init)] = show, init
        # Add HMM-specific liveplotters
        for show, init in getattr(stats.HMM, &#39;liveplotters&#39;, {}):
            potential_LPs[get_name(init)] = show, init

        def parse_figlist(lst):
            &#34;&#34;&#34;Figures requested for this xp. Convert to list.&#34;&#34;&#34;
            if isinstance(lst, str):
                fn = lst.lower()
                if &#34;all&#34; == fn:
                    lst = [&#34;all&#34;]  # All potential_LPs
                elif &#34;default&#34; in fn:
                    lst = [&#34;default&#34;]         # All show_by_default
            elif hasattr(lst, &#39;__len__&#39;):
                lst = lst            # This list (only)
            elif lst:
                lst = [&#34;default&#34;]             # All show_by_default
            else:
                lst = [None]         # None
            return lst
        figlist = parse_figlist(liveplots)

        # Loop over requeted figures
        self.figures = {}
        for name, (show_by_default, init) in potential_LPs.items():
            if (figlist == [&#34;all&#34;]) or \
                    (name in figlist) or \
                    (figlist == [&#34;default&#34;] and show_by_default):

                # Startup message
                if not self.any_figs:
                    print(&#39;Initializing liveplots...&#39;)
                    if is_notebook_or_qt:
                        pauses = [self.params[&#34;pause_&#34; + x] for x in &#34;faus&#34;]
                        if any((p &gt; 0) for p in pauses):
                            print(&#34;Note: liveplotting does not work very well&#34;
                                  &#34; inside Jupyter notebooks. In particular,&#34;
                                  &#34; there is no way to stop/skip them except&#34;
                                  &#34; to interrupt the kernel (the stop button&#34;
                                  &#34; in the toolbar). Consider using instead&#34;
                                  &#34; only the replay functionality (with infinite&#34;
                                  &#34; playback speed).&#34;)
                    elif not pb.disable_user_interaction:
                        print(&#39;Hit &lt;Space&gt; to pause/step.&#39;)
                        print(&#39;Hit &lt;Enter&gt; to resume/skip.&#39;)
                        print(&#39;Hit &lt;i&gt; to enter debug mode.&#39;)
                    self.paused = False
                    self.run_ipdb = False
                    self.skipping = False
                    self.any_figs = True

                # Init figure
                post_title = &#34;&#34; if self.plot_u else &#34;\n(obs times only)&#34;
                updater = init(name, stats, key0, self.plot_u, E, P, **kwargs)
                if plt.fignum_exists(name) and getattr(updater, &#39;is_active&#39;, 1):
                    self.figures[name] = updater
                    fig = plt.figure(name)
                    win = fig.canvas
                    ax0 = fig.axes[0]
                    win.manager.set_window_title(&#34;%s&#34; % name)
                    ax0.set_title(ax0.get_title() + post_title)
                    self.update(key0, E, P)  # Call initial update
                    plt.pause(0.01)          # Draw

    def update(self, key, E, P):
        &#34;&#34;&#34;Update liveplots&#34;&#34;&#34;
        # Check if there are still open figures
        if self.any_figs:
            open_figns = plt.get_figlabels()
            live_figns = set(self.figures.keys())
            self.any_figs = bool(live_figns.intersection(open_figns))
        else:
            return

        # Playback control
        SPACE  = b&#39; &#39;
        CHAR_I = b&#39;i&#39;
        ENTERs = [b&#39;\n&#39;, b&#39;\r&#39;]  # Linux + Windows

        def pause():
            &#34;&#34;&#34;Loop until user decision is made.&#34;&#34;&#34;
            ch = read1()
            while True:
                # Set state (pause, skipping, ipdb)
                if ch in ENTERs:
                    self.paused = False
                elif ch == CHAR_I:
                    self.run_ipdb = True
                # If keypress valid, resume execution
                if ch in ENTERs + [SPACE, CHAR_I]:
                    break
                ch = read1()
                # Pause to enable zoom, pan, etc. of mpl GUI
                plot_pause(0.01)  # Don&#39;t use time.sleep()!

        # Enter pause loop
        if self.paused:
            pause()

        else:
            if key == (0, None, &#39;u&#39;):
                # Skip read1 for key0 (coz it blocks)
                pass
            else:
                ch = read1()
                if ch == SPACE:
                    # Pause
                    self.paused = True
                    self.skipping = False
                    pause()
                elif ch in ENTERs:
                    # Toggle skipping
                    self.skipping = not self.skipping
                elif ch == CHAR_I:
                    # Schedule debug
                    # Note: The reason we dont set_trace(frame) right here is:
                    # - I could not find the right frame, even doing
                    #   &gt;   frame = inspect.stack()[0]
                    #   &gt;   while frame.f_code.co_name != &#34;assimilate&#34;:
                    #   &gt;       frame = frame.f_back
                    # - It just restarts the plot.
                    self.run_ipdb = True

        # Update figures
        if not self.skipping:
            faus = key[-1]
            if faus != &#39;u&#39; or self.plot_u:
                for name, (updater) in self.figures.items():
                    if plt.fignum_exists(name) and \
                            getattr(updater, &#39;is_active&#39;, 1):
                        _ = plt.figure(name)
                        updater(key, E, P)
                        plot_pause(self.params[&#39;pause_&#39;+faus])

        if self.run_ipdb:
            self.run_ipdb = False
            import inspect

            import ipdb
            print(&#34;Entering debug mode (ipdb).&#34;)
            print(&#34;Type &#39;?&#39; (and Enter) for usage help.&#34;)
            print(&#34;Type &#39;c&#39; to continue the assimilation.&#34;)
            ipdb.set_trace(inspect.stack()[2].frame)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dapper.tools.liveplotting.LivePlot.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, key, E, P)</span>
</code></dt>
<dd>
<div class="desc"><p>Update liveplots</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L178-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update(self, key, E, P):
    &#34;&#34;&#34;Update liveplots&#34;&#34;&#34;
    # Check if there are still open figures
    if self.any_figs:
        open_figns = plt.get_figlabels()
        live_figns = set(self.figures.keys())
        self.any_figs = bool(live_figns.intersection(open_figns))
    else:
        return

    # Playback control
    SPACE  = b&#39; &#39;
    CHAR_I = b&#39;i&#39;
    ENTERs = [b&#39;\n&#39;, b&#39;\r&#39;]  # Linux + Windows

    def pause():
        &#34;&#34;&#34;Loop until user decision is made.&#34;&#34;&#34;
        ch = read1()
        while True:
            # Set state (pause, skipping, ipdb)
            if ch in ENTERs:
                self.paused = False
            elif ch == CHAR_I:
                self.run_ipdb = True
            # If keypress valid, resume execution
            if ch in ENTERs + [SPACE, CHAR_I]:
                break
            ch = read1()
            # Pause to enable zoom, pan, etc. of mpl GUI
            plot_pause(0.01)  # Don&#39;t use time.sleep()!

    # Enter pause loop
    if self.paused:
        pause()

    else:
        if key == (0, None, &#39;u&#39;):
            # Skip read1 for key0 (coz it blocks)
            pass
        else:
            ch = read1()
            if ch == SPACE:
                # Pause
                self.paused = True
                self.skipping = False
                pause()
            elif ch in ENTERs:
                # Toggle skipping
                self.skipping = not self.skipping
            elif ch == CHAR_I:
                # Schedule debug
                # Note: The reason we dont set_trace(frame) right here is:
                # - I could not find the right frame, even doing
                #   &gt;   frame = inspect.stack()[0]
                #   &gt;   while frame.f_code.co_name != &#34;assimilate&#34;:
                #   &gt;       frame = frame.f_back
                # - It just restarts the plot.
                self.run_ipdb = True

    # Update figures
    if not self.skipping:
        faus = key[-1]
        if faus != &#39;u&#39; or self.plot_u:
            for name, (updater) in self.figures.items():
                if plt.fignum_exists(name) and \
                        getattr(updater, &#39;is_active&#39;, 1):
                    _ = plt.figure(name)
                    updater(key, E, P)
                    plot_pause(self.params[&#39;pause_&#39;+faus])

    if self.run_ipdb:
        self.run_ipdb = False
        import inspect

        import ipdb
        print(&#34;Entering debug mode (ipdb).&#34;)
        print(&#34;Type &#39;?&#39; (and Enter) for usage help.&#34;)
        print(&#34;Type &#39;c&#39; to continue the assimilation.&#34;)
        ipdb.set_trace(inspect.stack()[2].frame)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dapper.tools.liveplotting.sliding_diagnostics"><code class="flex name class">
<span>class <span class="ident">sliding_diagnostics</span></span>
<span>(</span><span>fignum, stats, key0, plot_u, E, P, Tplot=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a sliding window (like a heart rate monitor) of certain diagnostics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L264-L448" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class sliding_diagnostics:
    &#34;&#34;&#34;Plots a sliding window (like a heart rate monitor) of certain diagnostics.&#34;&#34;&#34;

    def __init__(self, fignum, stats, key0, plot_u,
                 E, P, Tplot=None, **kwargs):

        # STYLE TABLES - Defines which/how diagnostics get plotted
        styles = {}
        def lin(a, b): return (lambda x: a + b*x)
        divN = 1/getattr(stats.xp, &#39;N&#39;, 99)
        # Columns: transf, shape, plt kwargs
        styles[&#39;RMS&#39;] = {
            &#39;err.rms&#39;: [None, None, dict(c=&#39;k&#39;, label=&#39;Error&#39;)],
            &#39;std.rms&#39;: [None, None, dict(c=&#39;b&#39;, label=&#39;Spread&#39;, alpha=0.6)],
        }
        styles[&#39;Values&#39;] = {
            &#39;skew&#39;: [None, None, dict(c=&#39;g&#39;, label=star+r&#39;Skew/$\sigma^3$&#39;)],
            &#39;kurt&#39;: [None, None, dict(c=&#39;r&#39;, label=star+r&#39;Kurt$/\sigma^4{-}3$&#39;)],
            &#39;trHK&#39;: [None, None, dict(c=&#39;k&#39;, label=star+&#39;HK&#39;)],
            &#39;infl&#39;: [lin(-10, 10), &#39;step&#39;, dict(c=&#39;c&#39;, label=&#39;10(infl-1)&#39;)],
            &#39;N_eff&#39;: [lin(0, divN), &#39;dirac&#39;, dict(c=&#39;y&#39;, label=&#39;N_eff/N&#39;, lw=3)],
            &#39;iters&#39;: [lin(0, .1), &#39;dirac&#39;, dict(c=&#39;m&#39;, label=&#39;iters/10&#39;)],
            &#39;resmpl&#39;: [None, &#39;dirac&#39;, dict(c=&#39;k&#39;, label=&#39;resampled?&#39;)],
        }

        nAx = len(styles)
        GS = {&#39;left&#39;: 0.125, &#39;right&#39;: 0.76}
        fig, axs = place.freshfig(fignum, figsize=(5, 1+nAx),
                                  nrows=nAx, sharex=True, gridspec_kw=GS)

        axs[0].set_title(&#34;Diagnostics&#34;)
        for style, ax in zip(styles, axs):
            ax.set_ylabel(style)
        ax.set_xlabel(&#39;Time (t)&#39;)
        place_ax.adjust_position(ax, y0=0.03)

        self.T_lag, K_lag, a_lag = validate_lag(Tplot, stats.HMM.t)

        def init_ax(ax, style_table):
            lines = {}
            for name in style_table:

                # SKIP -- if stats[name] is not in existence
                # Note: The nan check/deletion comes after the first kObs.
                try:
                    stat = deep_getattr(stats, name)
                except AttributeError:
                    continue
                # try: val0 = stat[key0[0]]
                # except KeyError: continue
                # PS: recall (from series.py) that even if store_u is false, stat[k] is
                # still present if liveplots=True via the k_tmp functionality.

                # Unpack style
                ln = {}
                ln[&#39;transf&#39;] = style_table[name][0] or (lambda x: x)
                ln[&#39;shape&#39;]  = style_table[name][1]
                ln[&#39;plt&#39;]    = style_table[name][2]

                # Create series
                if isinstance(stat, FAUSt):
                    ln[&#39;plot_u&#39;] = plot_u
                    K_plot       = comp_K_plot(K_lag, a_lag, ln[&#39;plot_u&#39;])
                else:
                    ln[&#39;plot_u&#39;] = False
                    K_plot       = a_lag
                ln[&#39;data&#39;]   = RollingArray(K_plot)
                ln[&#39;tt&#39;]     = RollingArray(K_plot)

                # Plot (init)
                ln[&#39;handle&#39;], = ax.plot(ln[&#39;tt&#39;], ln[&#39;data&#39;], **ln[&#39;plt&#39;])

                # Plotting only nans yield ugly limits. Revert to defaults.
                ax.set_xlim(0, 1)
                ax.set_ylim(0, 1)

                lines[name] = ln
            return lines

        # Plot
        self.d = [init_ax(ax, styles[style]) for style, ax in zip(styles, axs)]

        # Horizontal line at y=0
        self.baseline0, = ax.plot(
            ax.get_xlim(), [0, 0], c=0.5*ones(3), lw=0.7, label=&#39;_nolegend_&#39;)

        # Store
        self.axs   = axs
        self.stats = stats
        self.init_incomplete = True

    # Update plot
    def __call__(self, key, E, P):
        k, kObs, faus = key

        stats  = self.stats
        chrono = stats.HMM.t
        ax0, ax1 = self.axs

        def update_arrays(lines):
            for name, ln in lines.items():
                stat = deep_getattr(stats, name)
                t    = chrono.tt[k]  # == chrono.ttObs[kObs]
                if isinstance(stat, FAUSt):
                    # ln[&#39;data&#39;] will contain duplicates for f/a times.
                    if ln[&#39;plot_u&#39;]:
                        val = stat[key]
                        ln[&#39;tt&#39;]  .insert(k, t)
                        ln[&#39;data&#39;].insert(k, ln[&#39;transf&#39;](val))
                    elif &#39;u&#39; not in faus:
                        val = stat[key]
                        ln[&#39;tt&#39;]  .insert(kObs, t)
                        ln[&#39;data&#39;].insert(kObs, ln[&#39;transf&#39;](val))
                else:
                    # ln[&#39;data&#39;] will not contain duplicates, coz only &#39;a&#39; is input.
                    if &#39;a&#39; in faus:
                        val = stat[kObs]
                        ln[&#39;tt&#39;]  .insert(kObs, t)
                        ln[&#39;data&#39;].insert(kObs, ln[&#39;transf&#39;](val))
                    elif &#39;f&#39; in faus:
                        pass

        def update_plot_data(ax, lines):

            def bend_into(shape, xx, yy):
                # Get arrays. Repeat (to use for intermediate nodes).
                yy = yy.array.repeat(3)
                xx = xx.array.repeat(3)
                if len(xx) == 0:
                    pass  # shortcircuit any modifications
                elif shape == &#39;step&#39;:
                    yy = np.hstack([yy[1:], nan])  # roll leftward
                elif shape == &#39;dirac&#39;:
                    nonlocal nDirac
                    axW      = np.diff(ax.get_xlim())
                    yy[0::3] = False           # set datapoin to 0
                    xx[2::3] = nan             # make datapoint disappear
                    xx      += nDirac*axW/100  # offset datapoint horizontally
                    nDirac  += 1
                return xx, yy

            nDirac = 1
            for _name, ln in lines.items():
                ln[&#39;handle&#39;].set_data(*bend_into(ln[&#39;shape&#39;], ln[&#39;tt&#39;], ln[&#39;data&#39;]))

        def finalize_init(ax, lines, mm):
            # Rm lines that only contain NaNs
            for name in list(lines):
                ln   = lines[name]
                stat = deep_getattr(stats, name)
                if not stat.were_changed:
                    ln[&#39;handle&#39;].remove()  # rm from axes
                    del lines[name]        # rm from dict
            # Add legends
            if lines:
                ax.legend(loc=&#39;upper left&#39;,
                          bbox_to_anchor=(1.01, 1), borderaxespad=0)
                if mm:
                    ax.annotate(star+&#34;: mean of\nmarginals&#34;,
                                xy=(0, -1.5/len(lines)),
                                xycoords=ax.get_legend().get_frame(),
                                bbox=dict(alpha=0.0), fontsize=&#39;small&#39;)
            # coz placement of annotate needs flush sometimes:
            plot_pause(0.01)

        # Insert current stats
        for lines, ax in zip(self.d, self.axs):
            update_arrays(lines)
            update_plot_data(ax, lines)

        # Set x-limits (time)
        sliding_xlim(ax0, self.d[0][&#39;err.rms&#39;][&#39;tt&#39;], self.T_lag, margin=True)
        self.baseline0.set_xdata(ax0.get_xlim())

        # Set y-limits
        data0 = [ln[&#39;data&#39;].array for ln in self.d[0].values()]
        data1 = [ln[&#39;data&#39;].array for ln in self.d[1].values()]
        ax0.set_ylim(0, d_ylim(data0, ax0             , cC=0.2, cE=0.9)[1])
        ax1.set_ylim(*d_ylim(data1, ax1, Max=4, Min=-4, cC=0.3, cE=0.9))

        # Init legend. Rm nan lines.
        if self.init_incomplete and &#39;a&#39; == faus:
            self.init_incomplete = False
            finalize_init(ax0, self.d[0], False)
            finalize_init(ax1, self.d[1], True)</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.weight_histogram"><code class="flex name class">
<span>class <span class="ident">weight_histogram</span></span>
<span>(</span><span>fignum, stats, key0, plot_u, E, P, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots histogram of weights. Refreshed each analysis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L473-L509" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class weight_histogram:
    &#34;&#34;&#34;Plots histogram of weights. Refreshed each analysis.&#34;&#34;&#34;

    def __init__(self, fignum, stats, key0, plot_u, E, P, **kwargs):
        if not hasattr(stats, &#39;w&#39;):
            self.is_active = False
            return
        fig, ax = place.freshfig(fignum, figsize=(7, 3), gridspec_kw={&#39;bottom&#39;: .15})

        ax.set_xscale(&#39;log&#39;)
        ax.set_xlabel(&#39;Weigth&#39;)
        ax.set_ylabel(&#39;Count&#39;)
        self.stats = stats
        self.ax    = ax
        self.hist  = []
        self.bins  = np.exp(np.linspace(np.log(1e-10), np.log(1), 31))

    def __call__(self, key, E, P):
        k, kObs, faus = key
        if &#39;a&#39; == faus:
            w  = self.stats.w[key]
            N  = len(w)
            ax = self.ax

            self.is_active = N &lt; 10001
            if not self.is_active:
                not_available_text(ax, &#39;Not computed (N &gt; threshold)&#39;)
                return

            counted = w &gt; self.bins[0]
            _ = [b.remove() for b in self.hist]
            nn, _, self.hist = ax.hist(
                w[counted], bins=self.bins, color=&#39;b&#39;)
            ax.set_ylim(top=max(nn))

            ax.set_title(&#39;N: {:d}.   N_eff: {:.4g}.   Not shown: {:d}. &#39;.
                         format(N, 1/(w@w), N-np.sum(counted)))</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.spectral_errors"><code class="flex name class">
<span>class <span class="ident">spectral_errors</span></span>
<span>(</span><span>fignum, stats, key0, plot_u, E, P, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the (spatial-RMS) error as a functional of the SVD index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L512-L557" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class spectral_errors:
    &#34;&#34;&#34;Plots the (spatial-RMS) error as a functional of the SVD index.&#34;&#34;&#34;

    def __init__(self, fignum, stats, key0, plot_u, E, P, **kwargs):
        fig, ax = place.freshfig(fignum, figsize=(6, 3))
        ax.set_xlabel(&#39;Sing. value index&#39;)
        ax.set_yscale(&#39;log&#39;)
        self.init_incomplete = True
        self.ax = ax
        self.plot_u = plot_u

        try:
            self.msft = stats.umisf
            self.sprd = stats.svals
        except AttributeError:
            self.is_active = False
            not_available_text(ax, &#34;Spectral stats not being computed&#34;)

    # Update plot
    def __call__(self, key, E, P):
        k, kObs, faus = key
        ax = self.ax
        if self.init_incomplete:
            if self.plot_u or &#39;f&#39; == faus:
                self.init_incomplete = False
                msft = abs(self.msft[key])
                sprd = self.sprd[key]
                if np.any(np.isinf(msft)):
                    not_available_text(ax, &#34;Spectral stats not finite&#34;)
                    self.is_active = False
                else:
                    self.line_msft, = ax.plot(
                        msft, &#39;k&#39;, lw=2, label=&#39;Error&#39;)
                    self.line_sprd, = ax.plot(
                        sprd, &#39;b&#39;, lw=2, label=&#39;Spread&#39;, alpha=0.9)
                    ax.get_xaxis().set_major_locator(
                        MaxNLocator(integer=True))
                    ax.legend()
        else:
            msft = abs(self.msft[key])
            sprd = self.sprd[key]
            self.line_sprd.set_ydata(sprd)
            self.line_msft.set_ydata(msft)
        # ax.set_ylim(*d_ylim(msft))
        # ax.set_ylim(bottom=1e-5)
        ax.set_ylim([1e-3, 1e1])</code></pre>
</details>
</dd>
<dt id="dapper.tools.liveplotting.correlations"><code class="flex name class">
<span>class <span class="ident">correlations</span></span>
<span>(</span><span>fignum, stats, key0, plot_u, E, P, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the state (auto-)correlation matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/liveplotting.py#L560-L658" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class correlations:
    &#34;&#34;&#34;Plots the state (auto-)correlation matrix.&#34;&#34;&#34;

    half = True  # Whether to show half/full (symmetric) corr matrix.

    def __init__(self, fignum, stats, key0, plot_u, E, P, **kwargs):

        GS = {&#39;height_ratios&#39;: [4, 1], &#39;hspace&#39;: 0.09, &#39;top&#39;: 0.95}
        fig, (ax, ax2) = place.freshfig(fignum, figsize=(5, 6), nrows=2, gridspec_kw=GS)

        if E is None and np.isnan(
                P.diag if isinstance(P, CovMat) else P).all():
            not_available_text(ax, (
                &#39;Not available in replays&#39;
                &#39;\ncoz full Ens/Cov not stored.&#39;))
            self.is_active = False
            return

        Nx = len(stats.mu[key0])
        if Nx &lt;= 1003:
            C = np.eye(Nx)
            # Mask half
            mask = np.zeros_like(C, dtype=np.bool)
            mask[np.tril_indices_from(mask)] = True
            # Make colormap. Log-transform cmap,
            # but not internally in matplotlib,
            # so as to avoid transforming the colorbar too.
            cmap = plt.get_cmap(&#39;RdBu_r&#39;)
            trfm = mpl.colors.SymLogNorm(linthresh=0.2, linscale=0.2,
                                         base=np.e, vmin=-1, vmax=1)
            cmap = cmap(trfm(np.linspace(-0.6, 0.6, cmap.N)))
            cmap = mpl.colors.ListedColormap(cmap)
            #
            VM   = 1.0  # abs(np.percentile(C,[1,99])).max()
            im   = ax.imshow(C, cmap=cmap, vmin=-VM, vmax=VM)
            # Colorbar
            _ = ax.figure.colorbar(im, ax=ax, shrink=0.8)
            # Tune plot
            plt.box(False)
            ax.set_facecolor(&#39;w&#39;)
            ax.grid(False)
            ax.set_title(&#34;State correlation matrix:&#34;, y=1.07)
            ax.xaxis.tick_top()

            # ax2 = inset_axes(ax,width=&#34;30%&#34;,height=&#34;60%&#34;,loc=3)
            line_AC, = ax2.plot(arange(Nx), ones(Nx), label=&#39;Correlation&#39;)
            line_AA, = ax2.plot(arange(Nx), ones(Nx), label=&#39;Abs. corr.&#39;)
            _        = ax2.hlines(0, 0, Nx-1, &#39;k&#39;, &#39;dotted&#39;, lw=1)
            # Align ax2 with ax
            bb_AC = ax2.get_position()
            bb_C  = ax.get_position()
            ax2.set_position([bb_C.x0, bb_AC.y0, bb_C.width, bb_AC.height])
            # Tune plot
            ax2.set_title(&#34;Auto-correlation:&#34;)
            ax2.set_ylabel(&#34;Mean value&#34;)
            ax2.set_xlabel(&#34;Distance (in state indices)&#34;)
            ax2.set_xticklabels([])
            ax2.set_yticks([0, 1] + list(ax2.get_yticks()[[0, -1]]))
            ax2.set_ylim(top=1)
            ax2.legend(frameon=True, facecolor=&#39;w&#39;,
                       bbox_to_anchor=(1, 1), loc=&#39;upper left&#39;, borderaxespad=0.02)

            self.ax      = ax
            self.ax2     = ax2
            self.im      = im
            self.line_AC = line_AC
            self.line_AA = line_AA
            self.mask    = mask
            if hasattr(stats, &#39;w&#39;):
                self.w   = stats.w
        else:
            not_available_text(ax)

    # Update plot
    def __call__(self, key, E, P):
        # Get cov matrix
        if E is not None:
            if hasattr(self, &#39;w&#39;):
                C = np.cov(E, rowvar=False, aweights=self.w[key])
            else:
                C = np.cov(E, rowvar=False)
        else:
            assert P is not None
            C = P.full if isinstance(P, CovMat) else P
            C = C.copy()
        # Compute corr from cov
        std = np.sqrt(np.diag(C))
        C  /= std[:, None]
        C  /= std[None, :]
        # Mask
        if self.half:
            C = np.ma.masked_where(self.mask, C)
        # Plot
        self.im.set_data(C)
        # Auto-corr function
        ACF = circulant_ACF(C)
        AAF = circulant_ACF(C, do_abs=True)
        self.line_AC.set_ydata(ACF)
        self.line_AA.set_ydata(AAF)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dapper.tools.liveplotting.correlations.half"><code class="name">var <span class="ident">half</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="DAPPER" href="https://nansencenter.github.io/DAPPER">
<img src="https://raw.githubusercontent.com/nansencenter/DAPPER/master/docs/imgs/logo_wtxt.png" alt="">
<!-- can add style="width:200px;" to img -->
</a>
</header>
<div class="gcse-search" style="height: 70px"
data-as_oq="inurl:github.com/nansencenter/DAPPER site:nansencenter.github.io/DAPPER"
data-gaCategoryParameter="dapper.tools.liveplotting">
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dapper.tools" href="index.html">dapper.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dapper.tools.liveplotting.sliding_xlim" href="#dapper.tools.liveplotting.sliding_xlim">sliding_xlim</a></code></li>
<li><code><a title="dapper.tools.liveplotting.circulant_ACF" href="#dapper.tools.liveplotting.circulant_ACF">circulant_ACF</a></code></li>
<li><code><a title="dapper.tools.liveplotting.sliding_marginals" href="#dapper.tools.liveplotting.sliding_marginals">sliding_marginals</a></code></li>
<li><code><a title="dapper.tools.liveplotting.phase_particles" href="#dapper.tools.liveplotting.phase_particles">phase_particles</a></code></li>
<li><code><a title="dapper.tools.liveplotting.validate_lag" href="#dapper.tools.liveplotting.validate_lag">validate_lag</a></code></li>
<li><code><a title="dapper.tools.liveplotting.comp_K_plot" href="#dapper.tools.liveplotting.comp_K_plot">comp_K_plot</a></code></li>
<li><code><a title="dapper.tools.liveplotting.update_alpha" href="#dapper.tools.liveplotting.update_alpha">update_alpha</a></code></li>
<li><code><a title="dapper.tools.liveplotting.duplicate_with_blanks_for_resampled" href="#dapper.tools.liveplotting.duplicate_with_blanks_for_resampled">duplicate_with_blanks_for_resampled</a></code></li>
<li><code><a title="dapper.tools.liveplotting.d_ylim" href="#dapper.tools.liveplotting.d_ylim">d_ylim</a></code></li>
<li><code><a title="dapper.tools.liveplotting.spatial1d" href="#dapper.tools.liveplotting.spatial1d">spatial1d</a></code></li>
<li><code><a title="dapper.tools.liveplotting.spatial2d" href="#dapper.tools.liveplotting.spatial2d">spatial2d</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dapper.tools.liveplotting.LivePlot" href="#dapper.tools.liveplotting.LivePlot">LivePlot</a></code></h4>
<ul class="">
<li><code><a title="dapper.tools.liveplotting.LivePlot.update" href="#dapper.tools.liveplotting.LivePlot.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dapper.tools.liveplotting.sliding_diagnostics" href="#dapper.tools.liveplotting.sliding_diagnostics">sliding_diagnostics</a></code></h4>
</li>
<li>
<h4><code><a title="dapper.tools.liveplotting.weight_histogram" href="#dapper.tools.liveplotting.weight_histogram">weight_histogram</a></code></h4>
</li>
<li>
<h4><code><a title="dapper.tools.liveplotting.spectral_errors" href="#dapper.tools.liveplotting.spectral_errors">spectral_errors</a></code></h4>
</li>
<li>
<h4><code><a title="dapper.tools.liveplotting.correlations" href="#dapper.tools.liveplotting.correlations">correlations</a></code></h4>
<ul class="">
<li><code><a title="dapper.tools.liveplotting.correlations.half" href="#dapper.tools.liveplotting.correlations.half">half</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
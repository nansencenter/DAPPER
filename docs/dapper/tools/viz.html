<!-- Search file for "CHANGE" for my own changes -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dapper.tools.viz API documentation</title>
<meta name="description" content="Tools for plotting." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://www.google.com">
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>
.gsc-control-cse {padding:0 !important;margin-top:1em}
body.gsc-overflow-hidden #sidebar {overflow: visible;}
</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="https://raw.githubusercontent.com/nansencenter/DAPPER/master/docs/imgs/logo.png">
<!-- Dont work coz pdoc already defines these:
<title>DAPPER doc</title>
<meta name="description" content="Data Assimilation with Python: a Package for Experimental Research" />
-->
<a href="https://github.com/nansencenter/DAPPER" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dapper.tools.viz</code></h1>
</header>
<section id="section-intro">
<p>Tools for plotting.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L0-L528" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Tools for plotting.&#34;&#34;&#34;

import time

import matplotlib as mpl
import numpy as np
from matplotlib import pyplot as plt
from matplotlib import ticker
from matplotlib.animation import FuncAnimation
from matplotlib.ticker import MaxNLocator
from mpl_tools import place
from numpy import arange, array
from patlib.std import find_1st_ind
from scipy.interpolate import interp1d

import dapper.tools.series as series
from dapper.tools.rounding import round2sigfig


def setup_wrapping(M, periodicity=None):
    &#34;&#34;&#34;Make state indices representative for periodic system.

    More accurately: Wrap the state indices and create a function that
    does the same for state vectors (or and ensemble thereof).

    Parameters
    ----------
    M: int
        Length of the periodic domain
    periodicity: bool, optional
        The mode of the wrapping.
        &#34;+1&#34;: the first element is appended after the last.
        &#34;+/-05&#34;: adding the midpoint of the first and last elements.
        Default: &#34;+1&#34;

    Returns
    -------
    ii: ndarray
        indices of periodic domain
    wrap: func
        transform non-periodic data into periodic data
    &#34;&#34;&#34;
    if periodicity in (None, True):
        periodicity = &#34;+1&#34;

    if periodicity == &#34;+1&#34;:
        ii = arange(M+1)

        def wrap(E):
            return E[..., list(range(M))+[0]]

    elif periodicity == &#34;+/-05&#34;:
        ii = np.hstack([-0.5, arange(M), M-0.5])

        def wrap(E):
            midpoint = (E[..., [0]] + E[..., [-1]])/2
            return np.concatenate([midpoint, E, midpoint], axis=-1)

    else:
        ii = arange(M)
        def wrap(x): return x

    return ii, wrap


def amplitude_animation(EE, dt=None, interval=1,
                        periodicity=None, blit=True,
                        fignum=None, repeat=False):
    &#34;&#34;&#34;Animation of line chart.

    Using an ensemble of
    the shape (time, ensemble size, state vector length).

    Parameters
    ----------
    EE: ndarray
        Ensemble arry of the shape (K, N, Nx).
        K is the length of time, N is the ensemble size, and
        Nx is the length of state vector.
    dt: float
        Time interval of each frame.
    interval: float, optional
        Delay between frames in milliseconds. Defaults to 200.
    periodicity: bool, optional
        The mode of the wrapping.
        &#34;+1&#34;: the first element is appended after the last.
        &#34;+/-05&#34;: adding the midpoint of the first and last elements.
        Default: &#34;+1&#34;
    blit: bool, optional
        Controls whether blitting is used to optimize drawing. Default: True
    fignum: int, optional
        Figure index. Default: None
    repeat: bool, optional
        If True, repeat the animation. Default: False
    &#34;&#34;&#34;
    fig, ax = place.freshfig(fignum or &#34;Amplitude animation&#34;)
    ax.set_xlabel(&#39;State index&#39;)
    ax.set_ylabel(&#39;Amplitue&#39;)
    ax.set_ylim(*stretch(*xtrema(EE), 1.1))

    if EE.ndim == 2:
        EE = np.expand_dims(EE, 1)
    K, N, Nx = EE.shape

    ii, wrap = setup_wrapping(Nx, periodicity)

    lines = ax.plot(ii, wrap(EE[0]).T)
    ax.set_xlim(*xtrema(ii))

    if dt is not None:
        times = &#39;time = %.1f&#39;
        lines += [ax.text(0.05, 0.9, &#39;&#39;, transform=ax.transAxes)]

    def anim(k):
        Ek = wrap(EE[k])
        for n in range(N):
            lines[n].set_ydata(Ek[n])
        if len(lines) &gt; N:
            lines[-1].set_text(times % (dt*k))
        return lines

    return FuncAnimation(fig, anim, range(K),
                         interval=interval, blit=blit,
                         repeat=repeat)


def xtrema(xx, axis=None):
    &#34;&#34;&#34;Get minimum and maximum of a sequence.

    Parameters
    ----------
    xx: ndarray
    axis: int, optional
        Specific axis for min and max. Defaults: None

    Returns
    -------
    a: float
        min value
    b: float
        max value
    &#34;&#34;&#34;
    a = np.nanmin(xx, axis)
    b = np.nanmax(xx, axis)
    return a, b


def stretch(a, b, factor=1, int_=False):
    &#34;&#34;&#34;Stretch distance `a-b` by factor.

    Parameters
    ----------
    a: float
        Lower bound of domain.
    b: float
        Upper bound of domain.
    factor: float, optional
        Streching factor. Defaults: 1
    int_: bool, optional
        If True, the domain bounds are integer.
        Defaults: False

    Returns
    -------
    a: float
        Lower bound of domain.
    b: float
        Upper bound of domain.
    &#34;&#34;&#34;
    c = (a+b)/2
    a = c + factor*(a-c)
    b = c + factor*(b-c)
    if int_:
        a = np.floor(a)
        b = np.ceil(b)
    return a, b


def set_ilim(ax, i, Min=None, Max=None):
    &#34;&#34;&#34;Set bounds on axis i.

    Parameters
    ----------
    ax: matplotlib.axes
    i: int
        1: x-axis; 2: y-axis; 3: z-axis
    Min: float, optional
        Lower bound limit. Defaults: None
    Max: float, optional
        Upper bound limit. Defaults: None
    &#34;&#34;&#34;
    if i == 0:
        ax.set_xlim(Min, Max)
    if i == 1:
        ax.set_ylim(Min, Max)
    if i == 2:
        ax.set_zlim(Min, Max)


def estimate_good_plot_length(xx, chrono=None, mult=100):
    &#34;&#34;&#34;Estimate the range of the xx slices for plotting.

    The length is based on the estimated time scale (wavelength)
    of the system.
    Provide sensible fall-backs (better if chrono is supplied).

    Parameters
    ----------
    xx: ndarray
        Plotted array
    chrono: `dapper.tools.chronos.Chronology`, optional
        object with property dkObS. Defaults: None
    mult: int, optional
        Number of waves for plotting. Defaults: 100

    Returns
    -------
    K: int
        length for plotting

    Example
    -------
    &gt;&gt;&gt; K_lag = estimate_good_plot_length(stats.xx, chrono, mult=80) # doctest: +SKIP
    &#34;&#34;&#34;
    if xx.ndim == 2:
        # If mult-dim, then average over dims (by ravel)....
        # But for inhomogeneous variables, it is important
        # to subtract the mean first!
        xx = xx - np.mean(xx, axis=0)
        xx = xx.ravel(order=&#39;F&#39;)

    try:
        K = mult * series.estimate_corr_length(xx)
    except ValueError:
        K = 0

    if chrono is not None:
        t = chrono
        K = int(min(max(K, t.dkObs), t.K))
        T = round2sigfig(t.tt[K], 2)  # Could return T; T&gt;tt[-1]
        K = find_1st_ind(t.tt &gt;= T)
        if K:
            return K
        else:
            return t.K
    else:
        K = int(min(max(K, 1), len(xx)))
        T = round2sigfig(K, 2)
        return K


def plot_pause(interval):
    &#34;&#34;&#34;Like `plt.pause`, but better.

    Actually works in Jupyter notebooks, unlike `plt.pause`.

    In regular mpl (interactive) backends: doesn&#39;t focus window.
    NB: doesn&#39;t create windows either.
    For that, use `plt.pause` or `plt.show` instead.
    &#34;&#34;&#34;
    # plt.pause(0) just seems to freeze execution.
    if interval == 0:
        return

    if mpl.get_backend() == &#34;nbAgg&#34;:  # ie. %matplotlib notebook
        # https://stackoverflow.com/q/34486642
        plt.gcf().canvas.draw()
        time.sleep(interval)

        # About the &#34;small&#34; figures: https://stackoverflow.com/a/66399257
        # It seems to me that it&#39;s using the &#34;inline&#34; backend until
        # the liveplotting finishes. Unfortunately the &#34;inline&#34;
        # backend is incompatible with &#34;stop/pause&#34; buttons.

    elif &#34;inline&#34; in mpl.get_backend():  # ie. %matplotlib inline
        # https://stackoverflow.com/a/29675706/38281
        # NB: Not working, but could possibly be made to work,
        # except that it won&#39;t support a &#34;pause/stop&#34; button.
        from IPython import display
        display.display(plt.gcf())
        display.clear_output(wait=True)
        time.sleep(interval)

    else:  # for non-notebook interactive backends

        # Implement plt.pause() that doesn&#39;t focus window, c.f.
        # https://github.com/matplotlib/matplotlib/issues/11131
        # https://stackoverflow.com/q/45729092
        # Only necessary for some platforms (e.g. Windows) and mpl versions.
        # Even then, mere figure creation may steal the focus.
        # This was done deliberately:
        # https://github.com/matplotlib/matplotlib/pull/6384#issue-69259165
        # https://github.com/matplotlib/matplotlib/issues/8246#issuecomment-505460935
        # from matplotlib import _pylab_helpers

        def _plot_pause(interval, focus_figure=True):
            canvas = plt.gcf().canvas
            manager = canvas.manager
            if manager is not None:
                if canvas.figure.stale:
                    canvas.draw_idle()
                if focus_figure:
                    plt.show(block=False)
                # if not is_notebook: # also see below
                if True:
                    canvas.start_event_loop(interval)
            else:
                time.sleep(interval)
        _plot_pause(interval, focus_figure=False)


def plot_hovmoller(xx, chrono=None, **kwargs):
    &#34;&#34;&#34;Plot Hovmöller diagram.

    Parameters
    ----------
    xx: ndarray
        Plotted array
    chrono: `dapper.tools.chronos.Chronology`, optional
        object with property dkObS. Defaults: None
    &#34;&#34;&#34;
    fig, ax = place.freshfig(&#34;Hovmoller&#34;, figsize=(4, 3.5))

    if chrono is not None:
        mask = chrono.tt &lt;= chrono.Tplot*2
        kk   = chrono.kk[mask]
        tt   = chrono.tt[mask]
        ax.set_ylabel(&#39;Time (t)&#39;)
    else:
        K    = estimate_good_plot_length(xx, mult=20)
        kk   = arange(K)
        tt   = kk
        ax.set_ylabel(&#39;Time indices (k)&#39;)

    plt.contourf(arange(xx.shape[1]), tt, xx[kk], 25)
    plt.colorbar()
    ax.get_xaxis().set_major_locator(MaxNLocator(integer=True))
    ax.set_title(&#34;Hovmoller diagram (of &#39;Truth&#39;)&#34;)
    ax.set_xlabel(&#39;Dimension index (i)&#39;)

    plt.pause(0.1)
    plt.tight_layout()


def integer_hist(E, N, centrd=False, weights=None, **kwargs):
    &#34;&#34;&#34;Histogram for integers.

    Parameters
    ----------
    E: ndarray
        Ensemble array.
    N: int
        Number of histogram bins.
    centrd: bool, optional
        If True, each bin is centered in the midpoint. Default: False
    weights: float, optional
        Weights for histogram. Default: None
    kwargs: dict
        keyword arguments for matplotlib.hist
    &#34;&#34;&#34;
    ax = plt.gca()
    rnge = (-0.5, N+0.5) if centrd else (0, N+1)
    ax.hist(E, bins=N+1, range=rnge, density=True, weights=weights, **kwargs)
    ax.set_xlim(rnge)


def not_available_text(ax, txt=None, fs=20):
    &#34;&#34;&#34;Plot given text on the figure

    Parameters
    ----------
    ax: matplotlib.axes
    txt: str, optional
        Printed text. Defaults: &#39;[Not available]&#39;
    fs: float, optional
        Font size. Defaults: 20.
    &#34;&#34;&#34;
    if txt is None:
        txt = &#39;[Not available]&#39;
    else:
        txt = &#39;[&#39; + txt + &#39;]&#39;
    ax.text(0.5, 0.5, txt,
            fontsize=fs,
            transform=ax.transAxes,
            va=&#39;center&#39;, ha=&#39;center&#39;,
            wrap=True)


def plot_err_components(stats):
    &#34;&#34;&#34;Plot components of the error.

    Parameters
    ----------
    stats: `dapper.stats.Stats`

    .. note::
      it was chosen to plot(ii, mean_in_time(abs(err_i))),
      and thus the corresponding spread measure is MAD.
      If one chose instead: plot(ii, std_in_time(err_i)),
      then the corresponding measure of spread would have been std.
      This choice was made in part because (wrt. subplot 2)
      the singular values (svals) correspond to rotated MADs,
      and because rms(umisf) seems to convoluted for interpretation.
    &#34;&#34;&#34;
    fig, (ax0, ax1, ax2) = place.freshfig(&#34;Error components&#34;, figsize=(6, 6), nrows=3)

    chrono = stats.HMM.t
    Nx     = stats.xx.shape[1]

    err   = np.mean(np.abs(stats.err.a), 0)
    sprd  = np.mean(stats.std.a, 0)
    umsft = np.mean(np.abs(stats.umisf.a), 0)
    usprd = np.mean(stats.svals.a, 0)

    ax0.plot(arange(Nx), err, &#39;k&#39;, lw=2, label=&#39;Error&#39;)
    if Nx &lt; 10**3:
        ax0.fill_between(arange(Nx), [0]*len(sprd), sprd, alpha=0.7, label=&#39;Spread&#39;)
    else:
        ax0.plot(arange(Nx), sprd, alpha=0.7, label=&#39;Spread&#39;)
    # ax0.set_yscale(&#39;log&#39;)
    ax0.set_title(&#39;Element-wise error comparison&#39;)
    ax0.set_xlabel(&#39;Dimension index (i)&#39;)
    ax0.set_ylabel(&#39;Time-average (_a) magnitude&#39;)
    ax0.set_xlim(0, Nx-1)
    ax0.get_xaxis().set_major_locator(MaxNLocator(integer=True))
    ax0.legend(loc=&#39;upper right&#39;)

    ax1.set_xlim(0, Nx-1)
    ax1.set_xlabel(&#39;Principal component index&#39;)
    ax1.set_ylabel(&#39;Time-average (_a) magnitude&#39;)
    ax1.set_title(&#39;Spectral error comparison&#39;)
    has_been_computed = np.any(np.isfinite(umsft))
    if has_been_computed:
        L = len(umsft)
        ax1.plot(arange(L), umsft, &#39;k&#39;, lw=2, label=&#39;Error&#39;)
        ax1.fill_between(arange(L), [0]*L, usprd, alpha=0.7, label=&#39;Spread&#39;)
        ax1.set_yscale(&#39;log&#39;)
        ax1.get_xaxis().set_major_locator(MaxNLocator(integer=True))
    else:
        not_available_text(ax1)

    rmse = stats.err.rms.a[chrono.maskObs_BI]
    ax2.hist(rmse, bins=30, density=False)
    ax2.set_ylabel(&#39;Num. of occurence (_a)&#39;)
    ax2.set_xlabel(&#39;RMSE&#39;)
    ax2.set_title(&#39;Histogram of RMSE values&#39;)
    ax2.set_xlim(left=0)

    plt.pause(0.1)
    plt.tight_layout()


def plot_rank_histogram(stats):
    &#34;&#34;&#34;Plot rank histogram of ensemble.

    Parameters
    ----------
    stats: `dapper.stats.Stats`
    &#34;&#34;&#34;
    chrono = stats.HMM.t

    has_been_computed = \
        hasattr(stats, &#39;rh&#39;) and \
        not all(stats.rh.a[-1] == array(np.nan).astype(int))

    fig, ax = place.freshfig(&#34;Rank histogram&#34;, figsize=(6, 3))
    ax.set_title(&#39;(Mean of marginal) rank histogram (_a)&#39;)
    ax.set_ylabel(&#39;Freq. of occurence\n (of truth in interval n)&#39;)
    ax.set_xlabel(&#39;ensemble member index (n)&#39;)

    if has_been_computed:
        ranks = stats.rh.a[chrono.maskObs_BI]
        Nx    = ranks.shape[1]
        N     = stats.xp.N
        if not hasattr(stats, &#39;w&#39;):
            # Ensemble rank histogram
            integer_hist(ranks.ravel(), N)
        else:
            # Experimental: weighted rank histogram.
            # Weight ranks by inverse of particle weight. Why? Coz, with correct
            # importance weights, the &#34;expected value&#34; histogram is then flat.
            # Potential improvement: interpolate weights between particles.
            w  = stats.w.a[chrono.maskObs_BI]
            K  = len(w)
            w  = np.hstack([w, np.ones((K, 1))/N])  # define weights for rank N+1
            w  = array([w[arange(K), ranks[arange(K), i]] for i in range(Nx)])
            w  = w.T.ravel()
            # Artificial cap. Reduces variance, but introduces bias.
            w  = np.maximum(w, 1/N/100)
            w  = 1/w
            integer_hist(ranks.ravel(), N, weights=w)
    else:
        not_available_text(ax)

    plt.pause(0.1)
    plt.tight_layout()


def axis_scale_by_array(ax, arr, axis=&#39;y&#39;, nbins=3):
    &#34;&#34;&#34;Scale axis so that the arr entries appear equidistant.

    The full transformation is piecewise-linear.

    Parameters
    ----------
    ax: matplotlib.axes
    arr: ndarray
        Array for plotting
    axis: str, optional
        Scaled axis, which can be &#39;x&#39;, &#39;y&#39; or &#39;z&#39;. Defaults: &#39;y&#39;
    nbins: int, optional
        Number of major ticks. Defaults: 3
    &#34;&#34;&#34;
    yy = array([y for y in arr if y is not None], dtype=float)  # rm None

    # Make transformation
    xx = arange(len(yy))
    func = interp1d(xx, yy, fill_value=&#34;extrapolate&#34;)
    invf = interp1d(yy, xx, fill_value=&#34;extrapolate&#34;)

    # Set transformation
    set_scale = eval(f&#34;ax.set_{axis}scale&#34;)
    set_scale(&#39;function&#39;, functions=(invf, func))

    # Adjust axis ticks
    _axis = getattr(ax, axis+&#34;axis&#34;)
    _axis.set_major_locator(ticker.FixedLocator(yy, nbins=nbins))
    _axis.set_minor_locator(ticker.FixedLocator(yy))
    _axis.set_minor_formatter(ticker.NullFormatter())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dapper.tools.viz.setup_wrapping"><code class="name flex">
<span>def <span class="ident">setup_wrapping</span></span>(<span>M, periodicity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Make state indices representative for periodic system.</p>
<p>More accurately: Wrap the state indices and create a function that
does the same for state vectors (or and ensemble thereof).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>M</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the periodic domain</dd>
<dt><strong><code>periodicity</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>The mode of the wrapping.
"+1": the first element is appended after the last.
"+/-05": adding the midpoint of the first and last elements.
Default: "+1"</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ii</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>indices of periodic domain</dd>
<dt><strong><code>wrap</code></strong> :&ensp;<code>func</code></dt>
<dd>transform non-periodic data into periodic data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L20-L63" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setup_wrapping(M, periodicity=None):
    &#34;&#34;&#34;Make state indices representative for periodic system.

    More accurately: Wrap the state indices and create a function that
    does the same for state vectors (or and ensemble thereof).

    Parameters
    ----------
    M: int
        Length of the periodic domain
    periodicity: bool, optional
        The mode of the wrapping.
        &#34;+1&#34;: the first element is appended after the last.
        &#34;+/-05&#34;: adding the midpoint of the first and last elements.
        Default: &#34;+1&#34;

    Returns
    -------
    ii: ndarray
        indices of periodic domain
    wrap: func
        transform non-periodic data into periodic data
    &#34;&#34;&#34;
    if periodicity in (None, True):
        periodicity = &#34;+1&#34;

    if periodicity == &#34;+1&#34;:
        ii = arange(M+1)

        def wrap(E):
            return E[..., list(range(M))+[0]]

    elif periodicity == &#34;+/-05&#34;:
        ii = np.hstack([-0.5, arange(M), M-0.5])

        def wrap(E):
            midpoint = (E[..., [0]] + E[..., [-1]])/2
            return np.concatenate([midpoint, E, midpoint], axis=-1)

    else:
        ii = arange(M)
        def wrap(x): return x

    return ii, wrap</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.amplitude_animation"><code class="name flex">
<span>def <span class="ident">amplitude_animation</span></span>(<span>EE, dt=None, interval=1, periodicity=None, blit=True, fignum=None, repeat=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Animation of line chart.</p>
<p>Using an ensemble of
the shape (time, ensemble size, state vector length).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>EE</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Ensemble arry of the shape (K, N, Nx).
K is the length of time, N is the ensemble size, and
Nx is the length of state vector.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Time interval of each frame.</dd>
<dt><strong><code>interval</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Delay between frames in milliseconds. Defaults to 200.</dd>
<dt><strong><code>periodicity</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>The mode of the wrapping.
"+1": the first element is appended after the last.
"+/-05": adding the midpoint of the first and last elements.
Default: "+1"</dd>
<dt><strong><code>blit</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Controls whether blitting is used to optimize drawing. Default: True</dd>
<dt><strong><code>fignum</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Figure index. Default: None</dd>
<dt><strong><code>repeat</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, repeat the animation. Default: False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L66-L124" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def amplitude_animation(EE, dt=None, interval=1,
                        periodicity=None, blit=True,
                        fignum=None, repeat=False):
    &#34;&#34;&#34;Animation of line chart.

    Using an ensemble of
    the shape (time, ensemble size, state vector length).

    Parameters
    ----------
    EE: ndarray
        Ensemble arry of the shape (K, N, Nx).
        K is the length of time, N is the ensemble size, and
        Nx is the length of state vector.
    dt: float
        Time interval of each frame.
    interval: float, optional
        Delay between frames in milliseconds. Defaults to 200.
    periodicity: bool, optional
        The mode of the wrapping.
        &#34;+1&#34;: the first element is appended after the last.
        &#34;+/-05&#34;: adding the midpoint of the first and last elements.
        Default: &#34;+1&#34;
    blit: bool, optional
        Controls whether blitting is used to optimize drawing. Default: True
    fignum: int, optional
        Figure index. Default: None
    repeat: bool, optional
        If True, repeat the animation. Default: False
    &#34;&#34;&#34;
    fig, ax = place.freshfig(fignum or &#34;Amplitude animation&#34;)
    ax.set_xlabel(&#39;State index&#39;)
    ax.set_ylabel(&#39;Amplitue&#39;)
    ax.set_ylim(*stretch(*xtrema(EE), 1.1))

    if EE.ndim == 2:
        EE = np.expand_dims(EE, 1)
    K, N, Nx = EE.shape

    ii, wrap = setup_wrapping(Nx, periodicity)

    lines = ax.plot(ii, wrap(EE[0]).T)
    ax.set_xlim(*xtrema(ii))

    if dt is not None:
        times = &#39;time = %.1f&#39;
        lines += [ax.text(0.05, 0.9, &#39;&#39;, transform=ax.transAxes)]

    def anim(k):
        Ek = wrap(EE[k])
        for n in range(N):
            lines[n].set_ydata(Ek[n])
        if len(lines) &gt; N:
            lines[-1].set_text(times % (dt*k))
        return lines

    return FuncAnimation(fig, anim, range(K),
                         interval=interval, blit=blit,
                         repeat=repeat)</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.xtrema"><code class="name flex">
<span>def <span class="ident">xtrema</span></span>(<span>xx, axis=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get minimum and maximum of a sequence.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xx</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Specific axis for min and max. Defaults: None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>min value</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>max value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L127-L145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xtrema(xx, axis=None):
    &#34;&#34;&#34;Get minimum and maximum of a sequence.

    Parameters
    ----------
    xx: ndarray
    axis: int, optional
        Specific axis for min and max. Defaults: None

    Returns
    -------
    a: float
        min value
    b: float
        max value
    &#34;&#34;&#34;
    a = np.nanmin(xx, axis)
    b = np.nanmax(xx, axis)
    return a, b</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.stretch"><code class="name flex">
<span>def <span class="ident">stretch</span></span>(<span>a, b, factor=1, int_=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Stretch distance <code>a-b</code> by factor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>Lower bound of domain.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>Upper bound of domain.</dd>
<dt><strong><code>factor</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Streching factor. Defaults: 1</dd>
<dt><strong><code>int_</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the domain bounds are integer.
Defaults: False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>Lower bound of domain.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>Upper bound of domain.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L148-L176" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def stretch(a, b, factor=1, int_=False):
    &#34;&#34;&#34;Stretch distance `a-b` by factor.

    Parameters
    ----------
    a: float
        Lower bound of domain.
    b: float
        Upper bound of domain.
    factor: float, optional
        Streching factor. Defaults: 1
    int_: bool, optional
        If True, the domain bounds are integer.
        Defaults: False

    Returns
    -------
    a: float
        Lower bound of domain.
    b: float
        Upper bound of domain.
    &#34;&#34;&#34;
    c = (a+b)/2
    a = c + factor*(a-c)
    b = c + factor*(b-c)
    if int_:
        a = np.floor(a)
        b = np.ceil(b)
    return a, b</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.set_ilim"><code class="name flex">
<span>def <span class="ident">set_ilim</span></span>(<span>ax, i, Min=None, Max=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set bounds on axis i.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>1: x-axis; 2: y-axis; 3: z-axis</dd>
<dt><strong><code>Min</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Lower bound limit. Defaults: None</dd>
<dt><strong><code>Max</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Upper bound limit. Defaults: None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L179-L197" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_ilim(ax, i, Min=None, Max=None):
    &#34;&#34;&#34;Set bounds on axis i.

    Parameters
    ----------
    ax: matplotlib.axes
    i: int
        1: x-axis; 2: y-axis; 3: z-axis
    Min: float, optional
        Lower bound limit. Defaults: None
    Max: float, optional
        Upper bound limit. Defaults: None
    &#34;&#34;&#34;
    if i == 0:
        ax.set_xlim(Min, Max)
    if i == 1:
        ax.set_ylim(Min, Max)
    if i == 2:
        ax.set_zlim(Min, Max)</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.estimate_good_plot_length"><code class="name flex">
<span>def <span class="ident">estimate_good_plot_length</span></span>(<span>xx, chrono=None, mult=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate the range of the xx slices for plotting.</p>
<p>The length is based on the estimated time scale (wavelength)
of the system.
Provide sensible fall-backs (better if chrono is supplied).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xx</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Plotted array</dd>
<dt><strong><code>chrono</code></strong> :&ensp;<code><a title="dapper.tools.chronos.Chronology" href="chronos.html#dapper.tools.chronos.Chronology">Chronology</a></code>, optional</dt>
<dd>object with property dkObS. Defaults: None</dd>
<dt><strong><code>mult</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of waves for plotting. Defaults: 100</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>K</code></strong> :&ensp;<code>int</code></dt>
<dd>length for plotting</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; K_lag = estimate_good_plot_length(stats.xx, chrono, mult=80) # doctest: +SKIP
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L200-L249" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def estimate_good_plot_length(xx, chrono=None, mult=100):
    &#34;&#34;&#34;Estimate the range of the xx slices for plotting.

    The length is based on the estimated time scale (wavelength)
    of the system.
    Provide sensible fall-backs (better if chrono is supplied).

    Parameters
    ----------
    xx: ndarray
        Plotted array
    chrono: `dapper.tools.chronos.Chronology`, optional
        object with property dkObS. Defaults: None
    mult: int, optional
        Number of waves for plotting. Defaults: 100

    Returns
    -------
    K: int
        length for plotting

    Example
    -------
    &gt;&gt;&gt; K_lag = estimate_good_plot_length(stats.xx, chrono, mult=80) # doctest: +SKIP
    &#34;&#34;&#34;
    if xx.ndim == 2:
        # If mult-dim, then average over dims (by ravel)....
        # But for inhomogeneous variables, it is important
        # to subtract the mean first!
        xx = xx - np.mean(xx, axis=0)
        xx = xx.ravel(order=&#39;F&#39;)

    try:
        K = mult * series.estimate_corr_length(xx)
    except ValueError:
        K = 0

    if chrono is not None:
        t = chrono
        K = int(min(max(K, t.dkObs), t.K))
        T = round2sigfig(t.tt[K], 2)  # Could return T; T&gt;tt[-1]
        K = find_1st_ind(t.tt &gt;= T)
        if K:
            return K
        else:
            return t.K
    else:
        K = int(min(max(K, 1), len(xx)))
        T = round2sigfig(K, 2)
        return K</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.plot_pause"><code class="name flex">
<span>def <span class="ident">plot_pause</span></span>(<span>interval)</span>
</code></dt>
<dd>
<div class="desc"><p>Like <code>plt.pause</code>, but better.</p>
<p>Actually works in Jupyter notebooks, unlike <code>plt.pause</code>.</p>
<p>In regular mpl (interactive) backends: doesn't focus window.
NB: doesn't create windows either.
For that, use <code>plt.pause</code> or <code>plt.show</code> instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L252-L309" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot_pause(interval):
    &#34;&#34;&#34;Like `plt.pause`, but better.

    Actually works in Jupyter notebooks, unlike `plt.pause`.

    In regular mpl (interactive) backends: doesn&#39;t focus window.
    NB: doesn&#39;t create windows either.
    For that, use `plt.pause` or `plt.show` instead.
    &#34;&#34;&#34;
    # plt.pause(0) just seems to freeze execution.
    if interval == 0:
        return

    if mpl.get_backend() == &#34;nbAgg&#34;:  # ie. %matplotlib notebook
        # https://stackoverflow.com/q/34486642
        plt.gcf().canvas.draw()
        time.sleep(interval)

        # About the &#34;small&#34; figures: https://stackoverflow.com/a/66399257
        # It seems to me that it&#39;s using the &#34;inline&#34; backend until
        # the liveplotting finishes. Unfortunately the &#34;inline&#34;
        # backend is incompatible with &#34;stop/pause&#34; buttons.

    elif &#34;inline&#34; in mpl.get_backend():  # ie. %matplotlib inline
        # https://stackoverflow.com/a/29675706/38281
        # NB: Not working, but could possibly be made to work,
        # except that it won&#39;t support a &#34;pause/stop&#34; button.
        from IPython import display
        display.display(plt.gcf())
        display.clear_output(wait=True)
        time.sleep(interval)

    else:  # for non-notebook interactive backends

        # Implement plt.pause() that doesn&#39;t focus window, c.f.
        # https://github.com/matplotlib/matplotlib/issues/11131
        # https://stackoverflow.com/q/45729092
        # Only necessary for some platforms (e.g. Windows) and mpl versions.
        # Even then, mere figure creation may steal the focus.
        # This was done deliberately:
        # https://github.com/matplotlib/matplotlib/pull/6384#issue-69259165
        # https://github.com/matplotlib/matplotlib/issues/8246#issuecomment-505460935
        # from matplotlib import _pylab_helpers

        def _plot_pause(interval, focus_figure=True):
            canvas = plt.gcf().canvas
            manager = canvas.manager
            if manager is not None:
                if canvas.figure.stale:
                    canvas.draw_idle()
                if focus_figure:
                    plt.show(block=False)
                # if not is_notebook: # also see below
                if True:
                    canvas.start_event_loop(interval)
            else:
                time.sleep(interval)
        _plot_pause(interval, focus_figure=False)</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.plot_hovmoller"><code class="name flex">
<span>def <span class="ident">plot_hovmoller</span></span>(<span>xx, chrono=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot Hovmöller diagram.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xx</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Plotted array</dd>
<dt><strong><code>chrono</code></strong> :&ensp;<code><a title="dapper.tools.chronos.Chronology" href="chronos.html#dapper.tools.chronos.Chronology">Chronology</a></code>, optional</dt>
<dd>object with property dkObS. Defaults: None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L312-L342" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot_hovmoller(xx, chrono=None, **kwargs):
    &#34;&#34;&#34;Plot Hovmöller diagram.

    Parameters
    ----------
    xx: ndarray
        Plotted array
    chrono: `dapper.tools.chronos.Chronology`, optional
        object with property dkObS. Defaults: None
    &#34;&#34;&#34;
    fig, ax = place.freshfig(&#34;Hovmoller&#34;, figsize=(4, 3.5))

    if chrono is not None:
        mask = chrono.tt &lt;= chrono.Tplot*2
        kk   = chrono.kk[mask]
        tt   = chrono.tt[mask]
        ax.set_ylabel(&#39;Time (t)&#39;)
    else:
        K    = estimate_good_plot_length(xx, mult=20)
        kk   = arange(K)
        tt   = kk
        ax.set_ylabel(&#39;Time indices (k)&#39;)

    plt.contourf(arange(xx.shape[1]), tt, xx[kk], 25)
    plt.colorbar()
    ax.get_xaxis().set_major_locator(MaxNLocator(integer=True))
    ax.set_title(&#34;Hovmoller diagram (of &#39;Truth&#39;)&#34;)
    ax.set_xlabel(&#39;Dimension index (i)&#39;)

    plt.pause(0.1)
    plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.integer_hist"><code class="name flex">
<span>def <span class="ident">integer_hist</span></span>(<span>E, N, centrd=False, weights=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Histogram for integers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>E</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Ensemble array.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of histogram bins.</dd>
<dt><strong><code>centrd</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, each bin is centered in the midpoint. Default: False</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Weights for histogram. Default: None</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>keyword arguments for matplotlib.hist</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L345-L364" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def integer_hist(E, N, centrd=False, weights=None, **kwargs):
    &#34;&#34;&#34;Histogram for integers.

    Parameters
    ----------
    E: ndarray
        Ensemble array.
    N: int
        Number of histogram bins.
    centrd: bool, optional
        If True, each bin is centered in the midpoint. Default: False
    weights: float, optional
        Weights for histogram. Default: None
    kwargs: dict
        keyword arguments for matplotlib.hist
    &#34;&#34;&#34;
    ax = plt.gca()
    rnge = (-0.5, N+0.5) if centrd else (0, N+1)
    ax.hist(E, bins=N+1, range=rnge, density=True, weights=weights, **kwargs)
    ax.set_xlim(rnge)</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.not_available_text"><code class="name flex">
<span>def <span class="ident">not_available_text</span></span>(<span>ax, txt=None, fs=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot given text on the figure</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Printed text. Defaults: '[Not available]'</dd>
<dt><strong><code>fs</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Font size. Defaults: 20.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L367-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def not_available_text(ax, txt=None, fs=20):
    &#34;&#34;&#34;Plot given text on the figure

    Parameters
    ----------
    ax: matplotlib.axes
    txt: str, optional
        Printed text. Defaults: &#39;[Not available]&#39;
    fs: float, optional
        Font size. Defaults: 20.
    &#34;&#34;&#34;
    if txt is None:
        txt = &#39;[Not available]&#39;
    else:
        txt = &#39;[&#39; + txt + &#39;]&#39;
    ax.text(0.5, 0.5, txt,
            fontsize=fs,
            transform=ax.transAxes,
            va=&#39;center&#39;, ha=&#39;center&#39;,
            wrap=True)</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.plot_err_components"><code class="name flex">
<span>def <span class="ident">plot_err_components</span></span>(<span>stats)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot components of the error.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stats</code></strong> :&ensp;<code><a title="dapper.stats.Stats" href="../stats.html#dapper.stats.Stats">Stats</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>it was chosen to plot(ii, mean_in_time(abs(err_i))),
and thus the corresponding spread measure is MAD.
If one chose instead: plot(ii, std_in_time(err_i)),
then the corresponding measure of spread would have been std.
This choice was made in part because (wrt. subplot 2)
the singular values (svals) correspond to rotated MADs,
and because rms(umisf) seems to convoluted for interpretation.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L389-L450" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot_err_components(stats):
    &#34;&#34;&#34;Plot components of the error.

    Parameters
    ----------
    stats: `dapper.stats.Stats`

    .. note::
      it was chosen to plot(ii, mean_in_time(abs(err_i))),
      and thus the corresponding spread measure is MAD.
      If one chose instead: plot(ii, std_in_time(err_i)),
      then the corresponding measure of spread would have been std.
      This choice was made in part because (wrt. subplot 2)
      the singular values (svals) correspond to rotated MADs,
      and because rms(umisf) seems to convoluted for interpretation.
    &#34;&#34;&#34;
    fig, (ax0, ax1, ax2) = place.freshfig(&#34;Error components&#34;, figsize=(6, 6), nrows=3)

    chrono = stats.HMM.t
    Nx     = stats.xx.shape[1]

    err   = np.mean(np.abs(stats.err.a), 0)
    sprd  = np.mean(stats.std.a, 0)
    umsft = np.mean(np.abs(stats.umisf.a), 0)
    usprd = np.mean(stats.svals.a, 0)

    ax0.plot(arange(Nx), err, &#39;k&#39;, lw=2, label=&#39;Error&#39;)
    if Nx &lt; 10**3:
        ax0.fill_between(arange(Nx), [0]*len(sprd), sprd, alpha=0.7, label=&#39;Spread&#39;)
    else:
        ax0.plot(arange(Nx), sprd, alpha=0.7, label=&#39;Spread&#39;)
    # ax0.set_yscale(&#39;log&#39;)
    ax0.set_title(&#39;Element-wise error comparison&#39;)
    ax0.set_xlabel(&#39;Dimension index (i)&#39;)
    ax0.set_ylabel(&#39;Time-average (_a) magnitude&#39;)
    ax0.set_xlim(0, Nx-1)
    ax0.get_xaxis().set_major_locator(MaxNLocator(integer=True))
    ax0.legend(loc=&#39;upper right&#39;)

    ax1.set_xlim(0, Nx-1)
    ax1.set_xlabel(&#39;Principal component index&#39;)
    ax1.set_ylabel(&#39;Time-average (_a) magnitude&#39;)
    ax1.set_title(&#39;Spectral error comparison&#39;)
    has_been_computed = np.any(np.isfinite(umsft))
    if has_been_computed:
        L = len(umsft)
        ax1.plot(arange(L), umsft, &#39;k&#39;, lw=2, label=&#39;Error&#39;)
        ax1.fill_between(arange(L), [0]*L, usprd, alpha=0.7, label=&#39;Spread&#39;)
        ax1.set_yscale(&#39;log&#39;)
        ax1.get_xaxis().set_major_locator(MaxNLocator(integer=True))
    else:
        not_available_text(ax1)

    rmse = stats.err.rms.a[chrono.maskObs_BI]
    ax2.hist(rmse, bins=30, density=False)
    ax2.set_ylabel(&#39;Num. of occurence (_a)&#39;)
    ax2.set_xlabel(&#39;RMSE&#39;)
    ax2.set_title(&#39;Histogram of RMSE values&#39;)
    ax2.set_xlim(left=0)

    plt.pause(0.1)
    plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.plot_rank_histogram"><code class="name flex">
<span>def <span class="ident">plot_rank_histogram</span></span>(<span>stats)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot rank histogram of ensemble.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stats</code></strong> :&ensp;<code><a title="dapper.stats.Stats" href="../stats.html#dapper.stats.Stats">Stats</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L453-L496" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot_rank_histogram(stats):
    &#34;&#34;&#34;Plot rank histogram of ensemble.

    Parameters
    ----------
    stats: `dapper.stats.Stats`
    &#34;&#34;&#34;
    chrono = stats.HMM.t

    has_been_computed = \
        hasattr(stats, &#39;rh&#39;) and \
        not all(stats.rh.a[-1] == array(np.nan).astype(int))

    fig, ax = place.freshfig(&#34;Rank histogram&#34;, figsize=(6, 3))
    ax.set_title(&#39;(Mean of marginal) rank histogram (_a)&#39;)
    ax.set_ylabel(&#39;Freq. of occurence\n (of truth in interval n)&#39;)
    ax.set_xlabel(&#39;ensemble member index (n)&#39;)

    if has_been_computed:
        ranks = stats.rh.a[chrono.maskObs_BI]
        Nx    = ranks.shape[1]
        N     = stats.xp.N
        if not hasattr(stats, &#39;w&#39;):
            # Ensemble rank histogram
            integer_hist(ranks.ravel(), N)
        else:
            # Experimental: weighted rank histogram.
            # Weight ranks by inverse of particle weight. Why? Coz, with correct
            # importance weights, the &#34;expected value&#34; histogram is then flat.
            # Potential improvement: interpolate weights between particles.
            w  = stats.w.a[chrono.maskObs_BI]
            K  = len(w)
            w  = np.hstack([w, np.ones((K, 1))/N])  # define weights for rank N+1
            w  = array([w[arange(K), ranks[arange(K), i]] for i in range(Nx)])
            w  = w.T.ravel()
            # Artificial cap. Reduces variance, but introduces bias.
            w  = np.maximum(w, 1/N/100)
            w  = 1/w
            integer_hist(ranks.ravel(), N, weights=w)
    else:
        not_available_text(ax)

    plt.pause(0.1)
    plt.tight_layout()</code></pre>
</details>
</dd>
<dt id="dapper.tools.viz.axis_scale_by_array"><code class="name flex">
<span>def <span class="ident">axis_scale_by_array</span></span>(<span>ax, arr, axis='y', nbins=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale axis so that the arr entries appear equidistant.</p>
<p>The full transformation is piecewise-linear.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>arr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array for plotting</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Scaled axis, which can be 'x', 'y' or 'z'. Defaults: 'y'</dd>
<dt><strong><code>nbins</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of major ticks. Defaults: 3</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/viz.py#L499-L529" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def axis_scale_by_array(ax, arr, axis=&#39;y&#39;, nbins=3):
    &#34;&#34;&#34;Scale axis so that the arr entries appear equidistant.

    The full transformation is piecewise-linear.

    Parameters
    ----------
    ax: matplotlib.axes
    arr: ndarray
        Array for plotting
    axis: str, optional
        Scaled axis, which can be &#39;x&#39;, &#39;y&#39; or &#39;z&#39;. Defaults: &#39;y&#39;
    nbins: int, optional
        Number of major ticks. Defaults: 3
    &#34;&#34;&#34;
    yy = array([y for y in arr if y is not None], dtype=float)  # rm None

    # Make transformation
    xx = arange(len(yy))
    func = interp1d(xx, yy, fill_value=&#34;extrapolate&#34;)
    invf = interp1d(yy, xx, fill_value=&#34;extrapolate&#34;)

    # Set transformation
    set_scale = eval(f&#34;ax.set_{axis}scale&#34;)
    set_scale(&#39;function&#39;, functions=(invf, func))

    # Adjust axis ticks
    _axis = getattr(ax, axis+&#34;axis&#34;)
    _axis.set_major_locator(ticker.FixedLocator(yy, nbins=nbins))
    _axis.set_minor_locator(ticker.FixedLocator(yy))
    _axis.set_minor_formatter(ticker.NullFormatter())</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="DAPPER" href="https://nansencenter.github.io/DAPPER">
<img src="https://raw.githubusercontent.com/nansencenter/DAPPER/master/docs/imgs/logo_wtxt.png" alt="">
<!-- can add style="width:200px;" to img -->
</a>
</header>
<div class="gcse-search" style="height: 70px"
data-as_oq="inurl:github.com/nansencenter/DAPPER site:nansencenter.github.io/DAPPER"
data-gaCategoryParameter="dapper.tools.viz">
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dapper.tools" href="index.html">dapper.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dapper.tools.viz.setup_wrapping" href="#dapper.tools.viz.setup_wrapping">setup_wrapping</a></code></li>
<li><code><a title="dapper.tools.viz.amplitude_animation" href="#dapper.tools.viz.amplitude_animation">amplitude_animation</a></code></li>
<li><code><a title="dapper.tools.viz.xtrema" href="#dapper.tools.viz.xtrema">xtrema</a></code></li>
<li><code><a title="dapper.tools.viz.stretch" href="#dapper.tools.viz.stretch">stretch</a></code></li>
<li><code><a title="dapper.tools.viz.set_ilim" href="#dapper.tools.viz.set_ilim">set_ilim</a></code></li>
<li><code><a title="dapper.tools.viz.estimate_good_plot_length" href="#dapper.tools.viz.estimate_good_plot_length">estimate_good_plot_length</a></code></li>
<li><code><a title="dapper.tools.viz.plot_pause" href="#dapper.tools.viz.plot_pause">plot_pause</a></code></li>
<li><code><a title="dapper.tools.viz.plot_hovmoller" href="#dapper.tools.viz.plot_hovmoller">plot_hovmoller</a></code></li>
<li><code><a title="dapper.tools.viz.integer_hist" href="#dapper.tools.viz.integer_hist">integer_hist</a></code></li>
<li><code><a title="dapper.tools.viz.not_available_text" href="#dapper.tools.viz.not_available_text">not_available_text</a></code></li>
<li><code><a title="dapper.tools.viz.plot_err_components" href="#dapper.tools.viz.plot_err_components">plot_err_components</a></code></li>
<li><code><a title="dapper.tools.viz.plot_rank_histogram" href="#dapper.tools.viz.plot_rank_histogram">plot_rank_histogram</a></code></li>
<li><code><a title="dapper.tools.viz.axis_scale_by_array" href="#dapper.tools.viz.axis_scale_by_array">axis_scale_by_array</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
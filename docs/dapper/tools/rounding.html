<!-- Search file for "CHANGE" for my own changes -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dapper.tools.rounding API documentation</title>
<meta name="description" content="Functions for rounding numbers." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://www.google.com">
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>
.gsc-control-cse {padding:0 !important;margin-top:1em}
body.gsc-overflow-hidden #sidebar {overflow: visible;}
</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="https://raw.githubusercontent.com/nansencenter/DAPPER/master/docs/imgs/logo.png">
<!-- Dont work coz pdoc already defines these:
<title>DAPPER doc</title>
<meta name="description" content="Data Assimilation with Python: a Package for Experimental Research" />
-->
<a href="https://github.com/nansencenter/DAPPER" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dapper.tools.rounding</code></h1>
</header>
<section id="section-intro">
<p>Functions for rounding numbers.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/rounding.py#L0-L271" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions for rounding numbers.&#34;&#34;&#34;

import functools
from dataclasses import dataclass

import numpy as np

from dapper.dpr_config import rc


@dataclass
class UncertainQtty():
    &#34;&#34;&#34;Data container associating uncertainty (confidence) to a quantity.

    Includes intelligent rounding and printing functionality.

    Usually, the precision parameter will be set to the (potentially estimated)
    standard deviation of an uncertain quantity.
    However, this class in itself does not define the `prec` attribute
    by anything else than what it does: impact the rounding &amp; printing of `val`.

    Examples:
    &gt;&gt;&gt; for c in [.01, .1, .2, .9, 1]:
    ...    print(UncertainQtty(1.2345, c))
    1.23 ±0.01
    1.2 ±0.1
    1.2 ±0.2
    1.2 ±0.9
    1 ±1

    &gt;&gt;&gt; for c in [.01, 1e-10, 1e-17, 0]:
    ...    print(UncertainQtty(1.2, c))
    1.20 ±0.01
    1.2000000000 ±1e-10
    1.19999999999999996 ±1e-17
    1.2000000000 ±0

    Note that in the case of a confidence of exactly 0,
    it defaults to 10 decimal places.
    Meanwhile, a NaN confidence yields printing using `rc.sigfig`:

    &gt;&gt;&gt; print(UncertainQtty(1.234567, np.nan))
    1.235 ±nan

    Also note the effect of large uncertainty:

    &gt;&gt;&gt; for c in [1, 9, 10, 11, 20, 100, np.inf]:
    ...    print(UncertainQtty(12, c))
    12 ±1
    12 ±9
    10 ±10
    10 ±10
    10 ±20
    0 ±100
    0 ±inf
    &#34;&#34;&#34;

    val: float
    prec: float

    def __post_init__(self):
        assert self.prec &gt;= 0. or np.isnan(self.prec), &#34;&#39;prec&#39; must be non-negative.&#34;

    def round(self=1.0):  # noqa
        &#34;&#34;&#34;Round intelligently.

        - `prec` to 1 sig.fig.
        - `val` to `round2(val, prec)`.
        &#34;&#34;&#34;
        if np.isnan(self.prec):
            # Fallback to rc.sigfig
            c = self.prec
            v = round2sigfig(self.val, rc.sigfig)
        else:
            # Normal/general case
            c = round2sigfig(self.prec, 1)
            v = round2(self.val, self.prec)
        return v, c

    def __str__(self):
        &#34;&#34;&#34;Returns &#39;val ±prec&#39;, using `UncertainQtty.round` and some finesse.&#34;&#34;&#34;
        v, c = self.round()

        if np.isnan(c):
            # Rounding to fallback (rc.sigfig) already took place
            return f&#34;{v} ±{c}&#34;
        elif c == 0:
            # 0 (i.e. not 1e-300) never arises &#34;naturally&#34; =&gt; Treat it &#34;magically&#34;
            # by truncating to a default. Also see https://stackoverflow.com/a/25899600
            n = -10
        else:
            # Normal/general case.
            n = log10int(c)

        frmt = &#34;%.f&#34;
        if n &lt; 0:
            # Ensure we get 1.30 ±0.01, NOT 1.3 ±0.01:
            frmt = &#34;%%0.%df&#34; % -n
        elif np.isfinite(c):
            # if c &gt;= 1.0
            c = int(c)
        v = frmt % v

        return f&#34;{v} ±{c}&#34;

    def __repr__(self):
        &#34;&#34;&#34;Essentially the same as `__str__`.&#34;&#34;&#34;
        v, c = str(self).split(&#34; ±&#34;)
        return self.__class__.__name__ + f&#34;(val={v}, prec={c})&#34;

    @property
    def prec(self):
        return self._prec

    @prec.setter
    def prec(self, prec):
        assert prec &gt;= 0. or np.isnan(prec), &#34;&#39;prec&#39; must be non-negative.&#34;
        self._prec = prec


def np_vectorize(f):
    &#34;&#34;&#34;Like `np.vectorize`, but with some embellishments.

    - Includes `functools.wraps`
    - Applies `.item()` to output if input was a scalar.

    Parameters
    ----------
    f: callable
        Your function.

    Returns
    -------
    vectorized: callable
        Your function, now element-wise applicable to an iterable.
    &#34;&#34;&#34;
    vectorized = np.vectorize(f)

    @functools.wraps(f)
    def new(*args, **kwargs):
        output = vectorized(*args, **kwargs)
        if np.isscalar(args[0]) and not isinstance(args[0], np.ndarray):
            output = output.item()
        return output

    return new


@np_vectorize
def _round2prec(num, prec):
    &#34;&#34;&#34;Don&#39;t use (directly)! Suffers from numerical precision.

    This function is left here just for reference. Use `round2` instead.

    The issue is that:
    &gt;&gt;&gt; _round2prec(0.7,.1)
    0.7000000000000001
    &#34;&#34;&#34;
    return prec * round(num / prec)


@np_vectorize
def log10int(x):
    &#34;&#34;&#34;Compute decimal order, rounded down.

    Conversion to `int` means that we cannot return nan&#39;s or +/- infinity,
    even though this could be meaningful. Instead, we return integers of magnitude
    a little less than IEEE floating point max/min-ima instead.
    This avoids a lot of clauses in the parent/callers to this function.

    Examples
    --------
    &gt;&gt;&gt; log10int([1e-1, 1e-2, 1, 3, 10, np.inf, -np.inf, np.nan])
    array([  -1,   -2,    0,    0,    1,  300, -300, -300])
    &#34;&#34;&#34;
    # Extreme cases -- https://stackoverflow.com/q/65248379
    if np.isnan(x):
        y = -300
    elif x &lt; 1e-300:
        y = -300
    elif x &gt; 1e+300:
        y = +300
    # Normal case
    else:
        y = int(np.floor(np.log10(np.abs(x))))
    return y


@np_vectorize
def round2(x, prec=1.0):
    r&#34;&#34;&#34;Round x to the decimal order appropriate for the precision.

    Parameters
    ----------
    x : array_like
        Value to be rounded.
    prec: float
        Precision, before prettify, which is given by
        $$ \text{prec} = 10^{\text{floor}(-\log_{10}|\text{prec}|)} $$

    Returns
    -------
    Rounded value (always a float).

    See Also
    --------
    `round2sigfig`

    Examples
    --------
    &gt;&gt;&gt; round2(1.65, 0.543)
    1.6
    &gt;&gt;&gt; round2(1.66, 0.543)
    1.7
    &gt;&gt;&gt; round2(1.65, 1.234)
    2.0
    &#34;&#34;&#34;
    if np.isnan(prec):
        return x
    ndecimal = -log10int(prec)
    return np.round(x, ndecimal)


@np_vectorize
def round2sigfig(x, sigfig=1):
    &#34;&#34;&#34;Round to significant figures.

    Parameters
    ----------
    x
        Value to be rounded.
    sigfig
        Number of significant figures to include.

    Returns
    -------
    rounded value (always a float).

    See Also
    --------
    np.round : rounds to a given number of *decimals*.
    `round2` : rounds to a given *precision*.

    Examples
    --------
    &gt;&gt;&gt; round2sigfig(1234.5678, 1)
    1000.0
    &gt;&gt;&gt; round2sigfig(1234.5678, 4)
    1235.0
    &gt;&gt;&gt; round2sigfig(1234.5678, 6)
    1234.57
    &#34;&#34;&#34;
    ndecimal = sigfig - log10int(x) - 1
    return np.round(x, ndecimal)


def is_whole(x, **kwargs):
    &#34;&#34;&#34;Check if a number is a whole/natural number to precision given by `np.isclose`.

    For actual type checking, use `isinstance(x, (int, np.integer))`.

    Parameters
    ----------
    x: float or ndarray
        Values to be checked

    Returns
    -------
    l: bool
        True if rounded x is close to x, otherwise False
    &#34;&#34;&#34;
    return np.isclose(x, round(x), **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dapper.tools.rounding.np_vectorize"><code class="name flex">
<span>def <span class="ident">np_vectorize</span></span>(<span>f)</span>
</code></dt>
<dd>
<div class="desc"><p>Like <code>np.vectorize</code>, but with some embellishments.</p>
<ul>
<li>Includes <code>functools.wraps</code></li>
<li>Applies <code>.item()</code> to output if input was a scalar.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>callable</code></dt>
<dd>Your function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>vectorized</code></strong> :&ensp;<code>callable</code></dt>
<dd>Your function, now element-wise applicable to an iterable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/rounding.py#L121-L146" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def np_vectorize(f):
    &#34;&#34;&#34;Like `np.vectorize`, but with some embellishments.

    - Includes `functools.wraps`
    - Applies `.item()` to output if input was a scalar.

    Parameters
    ----------
    f: callable
        Your function.

    Returns
    -------
    vectorized: callable
        Your function, now element-wise applicable to an iterable.
    &#34;&#34;&#34;
    vectorized = np.vectorize(f)

    @functools.wraps(f)
    def new(*args, **kwargs):
        output = vectorized(*args, **kwargs)
        if np.isscalar(args[0]) and not isinstance(args[0], np.ndarray):
            output = output.item()
        return output

    return new</code></pre>
</details>
</dd>
<dt id="dapper.tools.rounding.log10int"><code class="name flex">
<span>def <span class="ident">log10int</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute decimal order, rounded down.</p>
<p>Conversion to <code>int</code> means that we cannot return nan's or +/- infinity,
even though this could be meaningful. Instead, we return integers of magnitude
a little less than IEEE floating point max/min-ima instead.
This avoids a lot of clauses in the parent/callers to this function.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; log10int([1e-1, 1e-2, 1, 3, 10, np.inf, -np.inf, np.nan])
array([  -1,   -2,    0,    0,    1,  300, -300, -300])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/rounding.py#L162-L186" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@np_vectorize
def log10int(x):
    &#34;&#34;&#34;Compute decimal order, rounded down.

    Conversion to `int` means that we cannot return nan&#39;s or +/- infinity,
    even though this could be meaningful. Instead, we return integers of magnitude
    a little less than IEEE floating point max/min-ima instead.
    This avoids a lot of clauses in the parent/callers to this function.

    Examples
    --------
    &gt;&gt;&gt; log10int([1e-1, 1e-2, 1, 3, 10, np.inf, -np.inf, np.nan])
    array([  -1,   -2,    0,    0,    1,  300, -300, -300])
    &#34;&#34;&#34;
    # Extreme cases -- https://stackoverflow.com/q/65248379
    if np.isnan(x):
        y = -300
    elif x &lt; 1e-300:
        y = -300
    elif x &gt; 1e+300:
        y = +300
    # Normal case
    else:
        y = int(np.floor(np.log10(np.abs(x))))
    return y</code></pre>
</details>
</dd>
<dt id="dapper.tools.rounding.round2"><code class="name flex">
<span>def <span class="ident">round2</span></span>(<span>x, prec=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Round x to the decimal order appropriate for the precision.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Value to be rounded.</dd>
<dt><strong><code>prec</code></strong> :&ensp;<code>float</code></dt>
<dd>Precision, before prettify, which is given by
<span><span class="MathJax_Preview"> \text{prec} = 10^{\text{floor}(-\log_{10}|\text{prec}|)} </span><script type="math/tex; mode=display"> \text{prec} = 10^{\text{floor}(-\log_{10}|\text{prec}|)} </script></span></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rounded value (always a float).</p>
<h2 id="see-also">See Also</h2>
<p><code><a title="dapper.tools.rounding.round2sigfig" href="#dapper.tools.rounding.round2sigfig">round2sigfig()</a></code></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; round2(1.65, 0.543)
1.6
&gt;&gt;&gt; round2(1.66, 0.543)
1.7
&gt;&gt;&gt; round2(1.65, 1.234)
2.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/rounding.py#L189-L221" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@np_vectorize
def round2(x, prec=1.0):
    r&#34;&#34;&#34;Round x to the decimal order appropriate for the precision.

    Parameters
    ----------
    x : array_like
        Value to be rounded.
    prec: float
        Precision, before prettify, which is given by
        $$ \text{prec} = 10^{\text{floor}(-\log_{10}|\text{prec}|)} $$

    Returns
    -------
    Rounded value (always a float).

    See Also
    --------
    `round2sigfig`

    Examples
    --------
    &gt;&gt;&gt; round2(1.65, 0.543)
    1.6
    &gt;&gt;&gt; round2(1.66, 0.543)
    1.7
    &gt;&gt;&gt; round2(1.65, 1.234)
    2.0
    &#34;&#34;&#34;
    if np.isnan(prec):
        return x
    ndecimal = -log10int(prec)
    return np.round(x, ndecimal)</code></pre>
</details>
</dd>
<dt id="dapper.tools.rounding.round2sigfig"><code class="name flex">
<span>def <span class="ident">round2sigfig</span></span>(<span>x, sigfig=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Round to significant figures.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>Value to be rounded.</dd>
<dt><strong><code>sigfig</code></strong></dt>
<dd>Number of significant figures to include.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>rounded value (always a float).</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>np.round</code></dt>
<dd>rounds to a given number of <em>decimals</em>.
<code><code>&lt;a title="dapper.tools.rounding.round2" href="#dapper.tools.rounding.round2"&gt;round2()&lt;/a&gt;&lt;/code&gt; : rounds to a given *precision*.</code></dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; round2sigfig(1234.5678, 1)
1000.0
&gt;&gt;&gt; round2sigfig(1234.5678, 4)
1235.0
&gt;&gt;&gt; round2sigfig(1234.5678, 6)
1234.57
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/rounding.py#L224-L254" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@np_vectorize
def round2sigfig(x, sigfig=1):
    &#34;&#34;&#34;Round to significant figures.

    Parameters
    ----------
    x
        Value to be rounded.
    sigfig
        Number of significant figures to include.

    Returns
    -------
    rounded value (always a float).

    See Also
    --------
    np.round : rounds to a given number of *decimals*.
    `round2` : rounds to a given *precision*.

    Examples
    --------
    &gt;&gt;&gt; round2sigfig(1234.5678, 1)
    1000.0
    &gt;&gt;&gt; round2sigfig(1234.5678, 4)
    1235.0
    &gt;&gt;&gt; round2sigfig(1234.5678, 6)
    1234.57
    &#34;&#34;&#34;
    ndecimal = sigfig - log10int(x) - 1
    return np.round(x, ndecimal)</code></pre>
</details>
</dd>
<dt id="dapper.tools.rounding.is_whole"><code class="name flex">
<span>def <span class="ident">is_whole</span></span>(<span>x, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a number is a whole/natural number to precision given by <code>np.isclose</code>.</p>
<p>For actual type checking, use <code>isinstance(x, (int, np.integer))</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code> or <code>ndarray</code></dt>
<dd>Values to be checked</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if rounded x is close to x, otherwise False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/rounding.py#L257-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_whole(x, **kwargs):
    &#34;&#34;&#34;Check if a number is a whole/natural number to precision given by `np.isclose`.

    For actual type checking, use `isinstance(x, (int, np.integer))`.

    Parameters
    ----------
    x: float or ndarray
        Values to be checked

    Returns
    -------
    l: bool
        True if rounded x is close to x, otherwise False
    &#34;&#34;&#34;
    return np.isclose(x, round(x), **kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dapper.tools.rounding.UncertainQtty"><code class="flex name class">
<span>class <span class="ident">UncertainQtty</span></span>
<span>(</span><span>val: float, prec: float = &lt;property object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Data container associating uncertainty (confidence) to a quantity.</p>
<p>Includes intelligent rounding and printing functionality.</p>
<p>Usually, the precision parameter will be set to the (potentially estimated)
standard deviation of an uncertain quantity.
However, this class in itself does not define the <code>prec</code> attribute
by anything else than what it does: impact the rounding &amp; printing of <code>val</code>.</p>
<p>Examples:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; for c in [.01, .1, .2, .9, 1]:
...    print(UncertainQtty(1.2345, c))
1.23 ±0.01
1.2 ±0.1
1.2 ±0.2
1.2 ±0.9
1 ±1
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; for c in [.01, 1e-10, 1e-17, 0]:
...    print(UncertainQtty(1.2, c))
1.20 ±0.01
1.2000000000 ±1e-10
1.19999999999999996 ±1e-17
1.2000000000 ±0
</code></pre>
<p>Note that in the case of a confidence of exactly 0,
it defaults to 10 decimal places.
Meanwhile, a NaN confidence yields printing using <code>rc.sigfig</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; print(UncertainQtty(1.234567, np.nan))
1.235 ±nan
</code></pre>
<p>Also note the effect of large uncertainty:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; for c in [1, 9, 10, 11, 20, 100, np.inf]:
...    print(UncertainQtty(12, c))
12 ±1
12 ±9
10 ±10
10 ±10
10 ±20
0 ±100
0 ±inf
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/rounding.py#L12-L118" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class UncertainQtty():
    &#34;&#34;&#34;Data container associating uncertainty (confidence) to a quantity.

    Includes intelligent rounding and printing functionality.

    Usually, the precision parameter will be set to the (potentially estimated)
    standard deviation of an uncertain quantity.
    However, this class in itself does not define the `prec` attribute
    by anything else than what it does: impact the rounding &amp; printing of `val`.

    Examples:
    &gt;&gt;&gt; for c in [.01, .1, .2, .9, 1]:
    ...    print(UncertainQtty(1.2345, c))
    1.23 ±0.01
    1.2 ±0.1
    1.2 ±0.2
    1.2 ±0.9
    1 ±1

    &gt;&gt;&gt; for c in [.01, 1e-10, 1e-17, 0]:
    ...    print(UncertainQtty(1.2, c))
    1.20 ±0.01
    1.2000000000 ±1e-10
    1.19999999999999996 ±1e-17
    1.2000000000 ±0

    Note that in the case of a confidence of exactly 0,
    it defaults to 10 decimal places.
    Meanwhile, a NaN confidence yields printing using `rc.sigfig`:

    &gt;&gt;&gt; print(UncertainQtty(1.234567, np.nan))
    1.235 ±nan

    Also note the effect of large uncertainty:

    &gt;&gt;&gt; for c in [1, 9, 10, 11, 20, 100, np.inf]:
    ...    print(UncertainQtty(12, c))
    12 ±1
    12 ±9
    10 ±10
    10 ±10
    10 ±20
    0 ±100
    0 ±inf
    &#34;&#34;&#34;

    val: float
    prec: float

    def __post_init__(self):
        assert self.prec &gt;= 0. or np.isnan(self.prec), &#34;&#39;prec&#39; must be non-negative.&#34;

    def round(self=1.0):  # noqa
        &#34;&#34;&#34;Round intelligently.

        - `prec` to 1 sig.fig.
        - `val` to `round2(val, prec)`.
        &#34;&#34;&#34;
        if np.isnan(self.prec):
            # Fallback to rc.sigfig
            c = self.prec
            v = round2sigfig(self.val, rc.sigfig)
        else:
            # Normal/general case
            c = round2sigfig(self.prec, 1)
            v = round2(self.val, self.prec)
        return v, c

    def __str__(self):
        &#34;&#34;&#34;Returns &#39;val ±prec&#39;, using `UncertainQtty.round` and some finesse.&#34;&#34;&#34;
        v, c = self.round()

        if np.isnan(c):
            # Rounding to fallback (rc.sigfig) already took place
            return f&#34;{v} ±{c}&#34;
        elif c == 0:
            # 0 (i.e. not 1e-300) never arises &#34;naturally&#34; =&gt; Treat it &#34;magically&#34;
            # by truncating to a default. Also see https://stackoverflow.com/a/25899600
            n = -10
        else:
            # Normal/general case.
            n = log10int(c)

        frmt = &#34;%.f&#34;
        if n &lt; 0:
            # Ensure we get 1.30 ±0.01, NOT 1.3 ±0.01:
            frmt = &#34;%%0.%df&#34; % -n
        elif np.isfinite(c):
            # if c &gt;= 1.0
            c = int(c)
        v = frmt % v

        return f&#34;{v} ±{c}&#34;

    def __repr__(self):
        &#34;&#34;&#34;Essentially the same as `__str__`.&#34;&#34;&#34;
        v, c = str(self).split(&#34; ±&#34;)
        return self.__class__.__name__ + f&#34;(val={v}, prec={c})&#34;

    @property
    def prec(self):
        return self._prec

    @prec.setter
    def prec(self, prec):
        assert prec &gt;= 0. or np.isnan(prec), &#34;&#39;prec&#39; must be non-negative.&#34;
        self._prec = prec</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dapper.tools.rounding.UncertainQtty.val"><code class="name">var <span class="ident">val</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dapper.tools.rounding.UncertainQtty.prec"><code class="name">var <span class="ident">prec</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/rounding.py#L111-L113" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def prec(self):
    return self._prec</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dapper.tools.rounding.UncertainQtty.round"><code class="name flex">
<span>def <span class="ident">round</span></span>(<span>self=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Round intelligently.</p>
<ul>
<li><code>prec</code> to 1 sig.fig.</li>
<li><code>val</code> to <code><a title="dapper.tools.rounding.round2" href="#dapper.tools.rounding.round2">round2()</a>(val, prec)</code>.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/nansencenter/DAPPER/blob/master/dapper/tools/rounding.py#L64-L78" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def round(self=1.0):  # noqa
    &#34;&#34;&#34;Round intelligently.

    - `prec` to 1 sig.fig.
    - `val` to `round2(val, prec)`.
    &#34;&#34;&#34;
    if np.isnan(self.prec):
        # Fallback to rc.sigfig
        c = self.prec
        v = round2sigfig(self.val, rc.sigfig)
    else:
        # Normal/general case
        c = round2sigfig(self.prec, 1)
        v = round2(self.val, self.prec)
    return v, c</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="DAPPER" href="https://nansencenter.github.io/DAPPER">
<img src="https://raw.githubusercontent.com/nansencenter/DAPPER/master/docs/imgs/logo_wtxt.png" alt="">
<!-- can add style="width:200px;" to img -->
</a>
</header>
<div class="gcse-search" style="height: 70px"
data-as_oq="inurl:github.com/nansencenter/DAPPER site:nansencenter.github.io/DAPPER"
data-gaCategoryParameter="dapper.tools.rounding">
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dapper.tools" href="index.html">dapper.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dapper.tools.rounding.np_vectorize" href="#dapper.tools.rounding.np_vectorize">np_vectorize</a></code></li>
<li><code><a title="dapper.tools.rounding.log10int" href="#dapper.tools.rounding.log10int">log10int</a></code></li>
<li><code><a title="dapper.tools.rounding.round2" href="#dapper.tools.rounding.round2">round2</a></code></li>
<li><code><a title="dapper.tools.rounding.round2sigfig" href="#dapper.tools.rounding.round2sigfig">round2sigfig</a></code></li>
<li><code><a title="dapper.tools.rounding.is_whole" href="#dapper.tools.rounding.is_whole">is_whole</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dapper.tools.rounding.UncertainQtty" href="#dapper.tools.rounding.UncertainQtty">UncertainQtty</a></code></h4>
<ul class="">
<li><code><a title="dapper.tools.rounding.UncertainQtty.round" href="#dapper.tools.rounding.UncertainQtty.round">round</a></code></li>
<li><code><a title="dapper.tools.rounding.UncertainQtty.prec" href="#dapper.tools.rounding.UncertainQtty.prec">prec</a></code></li>
<li><code><a title="dapper.tools.rounding.UncertainQtty.val" href="#dapper.tools.rounding.UncertainQtty.val">val</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>